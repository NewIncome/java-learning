-Spring in Action- 5th Ed

Essentials
• Spring application context ,  is a Spring container that creates and manages application components
• Beans ,  are those components to be managed
• DependencyInjection(DI) ,  is the  act of wiring beans together is based on a pattern
  (pg.6(28))
• Component Scanning ,  with it Spring can automatically discover components from an application’s
   classpath and create them as beans in the Spring application context
• Autowiring ,  with it Spring automatically injects the components with the other beans that they depend on
• Autoconfiguration ,  with it  Spring Boot can make reasonable guesses of what components need
   to be configured and wired together, based on entries in the classpath, environment variables,
   and other factors
• Spring Tools ,  extension for VSCode
  ♦ called by ctrl + shift + p > 'Spring Initializr'

• Points on Project Structure, in src/main/resources          (pg.12(34))
  ♦ application.properties ,  place where you can specify configuration properties
  ♦ static/ ,  folder for static content (images, stylesheets, JavaScript, etc)
  ♦ templates/ ,  place for template files that will be used to render content to the browser
    ○ ie.: Thymleaf templates
• Why JAR?
  ♦ JAR packaging is a cloud-minded choice
  ♦ natural fit for most cloud platforms
  ♦ all Java cloud platforms are capable of running an executable JAR file
  ♦* the Spring Initializr defaults to JAR packaging unless you tell it to do otherwise
• Whereas WAR files are perfectly suitable for deploying to a traditional Java application server
  ♦ needs to include a web initializer class

• "Bootstrapping the Application"                             (pg.12(34))
  ♦ means starting the application's initial setup process
  ♦ This process typically involves:
    1. Loading Core Components: Loading essential classes and libraries into memory
    2. Initializing the Environment: Setting up system properties, environment variables, and configurations
    3. Creating the Main Container: For frameworks like Spring, it means creating the central
    container (like the ApplicationContext) that will manage all other components
• @SpringBootApplication
  ♦ is a composite application that combines three other
 annotations:
    1. @SpringBootConfiguration ,  this annotation is, in fact, a specialized form of the @Configuration annotatio
    2. @EnableAutoConfiguration ,  this annotation tells Spring Boot to automatically configure any components that it thinks you’ll need
    3. @ComponentScan ,  lets you declare other classes with annotations like @Component, @Controller, @Service, and others,
        to have Spring automatically discover them and register them as components in the Spring application context
  ♦ SpringApplication.run() performs the actual bootstrapping of the application, creating the Spring application context
    ○ .run( Configuration Class, Command-line arguments )

Writting a Spring Application
• @Controller ,  general purpose annotation, but used for better descriptiveness
• @GetMapping("/") ,  http get request handler
  ♦ The return value is interpreted as the logical name of a view
• The template for the 'home' view is in src/main/resources/templates/home.html
• Images should referenced with Thymeleaf are written as follows:
   <img th:src="@{/images/TacoCloud.png}"/>
  ♦ Thymeleaf uses th:src attribute and an @{...} expression to reference the image with a context relative path
• Images go in the dir src/main/resources/static/images/TacoCloud.png
• @WebMvcTest ,  is a special test-annotation provided by Spring Boot that arranges for the test to run in the context of a Spring MVC application
(pg.20(42))

• SpringBoot Dev Tools
  comes with:
  ♦ Automatic application restart when code changes
  ♦ Automatic browser refresh when browser-destined resources (such as templates, JavaScript, stylesheets, and so on) change
  ♦ Automatic disable of template caches
  ♦ Built in H2 Console if the H2 database is in use
    ○ Accesible at http://localhost:8080/h2-console , to gain insight into the data your application is working with

Important dependencies and what they offer
• The 'core Spring Framework'
  ♦ is the foundation of everything else in the Spring universe
  ♦ it provides:
    ○ the core container 
    ○ dependency injection framework
    ○ Spring MVC
    ○ some elemental data persistence support, specifically template-based JDBC support
    ○ support for reactive-style programming (Spring WebFlux)
• 'SpringBoot'
  ♦ starter dependencies
  ♦ autoconfiguration
  ♦ the 'Actuator', provides runtime insight into the inner workings of an application
  ♦ flexible specification of environment properties
  ♦ additional testing support
  ♦ Spring Boot CLI,  an alternative programming model based on Groovy scripts
• 'Spring Data'
  ♦ adds the ability to define your application’s data repositories as simple Java interfaces
  ♦ using a naming convention when defining methods to drive how data is stored and retrieved
  ♦ is capable of working with different kinds of DBs like: JPA, Mongo, Neo4j
• 'Spring Security'
  ♦ addresses authentication, authorization, and API security
• ' Spring Integration' and 'Spring Batch'
  ♦  provide the implementation of patterns of application integration
• 'Spring Cloud'
  ♦ a collection of projects for developing cloud-native applications with Spring
  ♦ helps microservices

//• A "repository" ,  is a software design pattern used to manage data persistence
     It acts as an abstraction layer between the application's business logic and the
     data source (like a database, file system, or a remote API)
    ♦ When developers talk about repositories, they're referring to a class or interface
    that handles all the low-level details of how to: Create, Read, Update, and Delete an object

• Domain
  ♦ An application’s domain is the subject area that it addresses—the ideas and
  concepts that influence the understanding of the application
  ♦ Like: +taco designs, +ingredients, +customers, and +taco-orders
•* for Domain classes it's very usefull to make use of 2 special Java feats:
  1♦ Lombok ,  Java library(dependency) that reduces boilerplate code
    ○* all the boilerplate that is normally associated with simple POJOs (Plain Old Java Objects) and beans
    ○ It uses annotations to automatically generate code during the compile phase, such as
      ◘ @Getter ,  creates the getter method to the field
      ◘ @Setter ,  creates the setter method to the field
      ◘ @Data ,  bundles several annotations together
        ◙ Getters: for all private fields
        ◙ Setters: for all non-final fields (these will be set in the constructor)
        ◙ toString(): with @ToString it provides string representation of the object details(fields)
          ♣ it includes the class name and the value of each field
        ◙ equals(): to directly compare objects(automatically does it by value)
        ◙ hashCode(): using the @EqualsAndHashCode annotation
          ♣ it computes a hash code from all the non-static, non-transient fields in the class
          ♣ it's crucial for correctly storing and retrieving objects in hash-based collections like HashMap and HashSet
      ◘ @RequiredArgsConstructor ,  generates a constructor for every final field and every field annotated with @NonNull that is not already initialized

• ENUM
  ♦ (enumeration) is a special data type in Java that allows a variable to be a set of predefined constants
  ♦ The enum declaration defines a class (called an enum type)
  ♦ More Than Just Constants, They are classes under the hood and can have their own fields, constructors, and methods
  ♦ An enum is essentially a class with a fixed number of instances(the Constants) which are public, static, and final
  ♦ key features of enums:
    ○ Type safety: the values cannot be repeated and are checked against l/u-cassing
    ○ Readability: due to the use of named constants
    ○ Versatility: because they're not simple constants. They are classes under the hood and can have their own fields, constructors, and methods
  ♦ ie.:  public enum DayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
            FRIDAY, SATURDAY, SUNDAY }
          //you use it like so:
          DayOfWeek today = DayOfWeek.MONDAY;
  ♦ It can have it's own 'main' method for testing
  ♦ ie.(example with Fields and Methods):
      public enum DayOfWeekWithFields {
        MONDAY(true), TUESDAY(true), WEDNESDAY(true), THURSDAY(true),
        FRIDAY(true), SATURDAY(false), SUNDAY(false);

        private final boolean isWeekday;

        // Constructor for the enum constants
        DayOfWeekWithFields(boolean isWeekday) {
            this.isWeekday = isWeekday;
        }

        // Method to check the value
        public boolean isWeekday() {
            return isWeekday;
        }
      }
  ♦ an enum cannot extend anything else, besides the implicite extend for java.lang.Enum
  ♦ The compiler automatically adds some special methods when it creates an enum:
    ○ A static values() method that returns an array containing all of the values of the enum in the order they are declared
    ○ A constructor for the enum type that must be package-private or private access(by default)
      ◘ It automatically creates the constants that are defined at the beginning of the enum body
         It accepts all final properties as arguments
      ◘* You cannot invoke an enum constructor yourself
      ◘//* Check the Planet.java as a great example for the enum type, with all it's special feats
            run the Planet.class with:  $ java Planet 175  # to get:  Your weight on MERCURY is 66.107583 ...

Controller Creation
•// Logger: software component or utility used to record and output information about a program's execution
  ♦ This information is typically written to a log file, console, or another output stream
• @Slf4j ,  is a Lombok-provided annotation for logger creation
  ♦ at runtime will automatically generate an SLF4J (Simple Logging Facade for Java, https://www.slf4j.org/) Logger in the class
  ♦ this annotation is the same as adding the following line:
     private static final org.slf4j.Logger log =
      org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);
  ♦ It essentially does three things:
    1○ Declares a logger variable: It automatically creates a private static final field named log (or LOG) of type org.slf4j.Logger
    2○ Initializes the logger
    3○ Hides the boilerplate
• @Controller ,  mark the class as a candidate for component scanning
  //so that Spring will discover it and automatically create an instance of the Controller as a bean in the Spring application context
• @RequestMapping("path") ,  specifies the kind of requests that this controller handles
  ♦ Maps web requests to specific methods in a controller class
• @GetMapping ,  specifies that when an HTTP GET request is received for the page specified in the @RequestMapping, the following method will be called to handle the request
  ♦  Prior to Spring 4.3, you might have used a method-level @RequestMapping annota tion instead:
      @RequestMapping(method=RequestMethod.GET)
• Spring MVC request-mapping annotations
  ♦ @RequestMapping    General-purpose request handling
  ♦ @GetMapping        Handles HTTP GET requests
  ♦ @PostMapping       Handles HTTP POST requests
  ♦ @PutMapping        Handles HTTP PUT requests
  ♦ @DeleteMapping     Handles HTTP DELETE requests
  ♦ @PatchMapping      Handles HTTP PATCH requests
• Model ,  is an object that ferries data between a controller and whatever view is charged with rendering that data
  ♦ class imported from org.springframework.ui.Model
  ♦ data that’s placed in Model attributes is copied into the servlet response attributes,
    where the view can find them

View Creation
• Spring options for defining views:
  ♦ JavaServer Pages (JSP), Thymeleaf, FreeMarker, Mustache, and Groovy-based templates
• Thymeleaf ,  
  ♦ View libraries such as Thymeleaf are designed to be decoupled from any particular web framework
  ♦ they’re unaware of Spring’s model abstraction and are unable to work with the data that the controller places in Model
  ♦ But they can work with "servlet request attributes"
  ♦ Thymeleaf-namespaced attribute that perform actions or data binding:
    ○ you use them as attributes of html elements
    ○ th:text , to retrieve text  ->   <p th:text="${message}">placeholder message</p>
       and replaces the text value of the element with the th-text-value
    ○ th:each ,  for iteration  -> ie.:  th:each="itemVariable : collection"
       ie.: <div th:each="ingredient : ${wrap}">
              <input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
              <span th:text="${ingredient.name}">INGREDIENT</span><br/>
            </div>
      ◘ : ${wrap} ,  to render just the list of "wrap" ingredients
    ○ th:value ,   sets the rendered <input> element’s value attribute to the th:value found
    ○ th:href ,  to define href attribute  ->  <link rel="stylesheet" th:href="@{/styles.css}"/>
    ○ th:src ,  to define src attribute  ->  <img th:src="@{/images/TacoCloud.png}"/>
    ○ th:field ,  to define field attribute  ->  <input type="text" th:field="*{name}"/>
    ○ th:object ,  ->  <form method="POST" th:object="${design}">
      ◘ Serves as the central model for your form
      ◘ Sets the Context: tells the form to bind its fields to the properties of the design object passed from the Spring controller
      ◘ Facilitates Data Binding: Once the object is set, you can use th:field on form inputs (like <input>, <select>, and <textarea>)
        to bind them to a specific property of that object.
      ◘ Error Handling: It works with Spring's validation framework.
      ◘ If a form submission fails validation, th:object and th:field can automatically display error messages next to the corresponding form fields.
    * another example for the iteration with Thymeleaf:
       //Java file
       model.addAttribute("tacos", List.of(new Taco("Carnitas"), new Taco("Veggie")));
       //HTML
       <ul id="tacoList">
         <li th:each="taco : ${tacos}" th:text="${taco.name}">placeholder to be replaced</li>

Model in Java
• A Model is a class that represents a data structure or a real-world object
• It's a core component of the Model-View-Controller (MVC) design pattern
• Its primary purpose is to hold and manage the application's data and business logic
• The model knows nothing about how it will be displayed on a web page or how it will be created from a form
• The org.springframework.ui.Model
  ♦ is a core interface in Spring MVC
  ♦ It's a lightweight, map-like object that acts as a container for data,
    -passing it from a controller to a view-
  ♦ when assigned as method parameter  ->  public String showDesignForm(Model model)
    assigned n called by key value to the view  ->  model.addAttribute("key", "value");
      model.addAttribute("message", "Hello, world!");
      model.addAttribute("user", user);  //user is the whole object with it's instance variables and methods
      view-> ${message}  ${user.name}
• @ModelAttribute ,  Spring annotation to bind data from a web request to a Java object
  ♦ It works in two main ways, depending on where you place it
    1○ As a Method Parameter. (Most common use)IT tell spring to do the following:
      ◘ Create an instance of the specified object
      ◘ Bind data from the incoming request (e.g., form fields) to the object's properties
      ◘ Add this newly populated object to the Model so it can be accessed in the view
      ◘ ie.:
        @PostMapping("/orders")
        public String processOrder(@ModelAttribute Order order) {
          orderRepository.save(order);
          return "redirect:/";
        }
        // The 'order' object is automatically created and populated with form data.
        // It's also added to the model with the key "order".
    2○ As a Method-Level Annotation. When placed on a method
      ◘ It tells Spring to execute that method before any request-mapping methods in the same controller
        The return value of the method is then added to the Model
      ◘ ie.:
        @Controller
        public class DesignController {
            
            // This method will be called before any other methods in this controller.
            @ModelAttribute(name = "ingredients")
            public List<Ingredient> addIngredientsToModel() {
                return ingredientRepository.findAll();
            }
            
            @GetMapping("/design")
            public String showDesignForm() {
                // The "ingredients" list is already in the model and can be used in the "design" view.
                return "design";
            }
        }
•//* ¡¡¡The Model object only exists within the scope of your controller method!!!

DEBUGGING
• In IntellijIDEA
  1♦ Add Run > Edit Configurations... > Remote JVM Debug
  2♦ Use a better name, everything else stays the same
  3♦ It'll listen on port 5005, so you’ll need to run mvn cli
  4♦ In your project terminal run:
    $ mvn spring-boot:run -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"

• In VSCode
  1♦ Install the 'Spring Boot Extension Pack'
  2♦ Click on the SpringBootDashboard button
  3♦ Right click in apps > YourProjectName > debug
  4♦ VSCode Spring Boot extension should take care of the configuration
    ○ It created this config in launch.json:
      {
        "configurations": [
          {
            "type": "java",
            "name": "Spring Boot-TacoCloudApplication<taco-cloud>",
            "request": "launch",
            "cwd": "${workspaceFolder}",
            "mainClass": "com.jalfredev.taco_cloud.TacoCloudApplication",
            "projectName": "taco-cloud",
            "args": "",
            "envFile": "${workspaceFolder}/.env"
          }
        ]
      }
  !♦ DO NOT TRY TO DEBUG STRAIGHT FROM THE 'RUN AND DEBUG' BUTTON, who knows with what it works


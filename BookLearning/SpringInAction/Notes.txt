-Spring in Action- 5th Ed

Essentials
• Spring application context ,  is a Spring container that creates and manages application components
• Beans ,  are those components to be managed
• DependencyInjection(DI) ,  is the  act of wiring beans together is based on a pattern
  (pg.6(28))
• Component Scanning ,  with it Spring can automatically discover components from an application’s
   classpath and create them as beans in the Spring application context
• Autowiring ,  with it Spring automatically injects the components with the other beans that they depend on
• Autoconfiguration ,  with it  Spring Boot can make reasonable guesses of what components need
   to be configured and wired together, based on entries in the classpath, environment variables,
   and other factors
• Spring Tools ,  extension for VSCode
  ♦ called by ctrl + shift + p > 'Spring Initializr'

• Points on Project Structure, in src/main/resources          (pg.12(34))
  ♦ application.properties ,  place where you can specify configuration properties
  ♦ static/ ,  folder for static content (images, stylesheets, JavaScript, etc)
  ♦ templates/ ,  place for template files that will be used to render content to the browser
    ○ ie.: Thymleaf templates
• Why JAR?
  ♦ JAR packaging is a cloud-minded choice
  ♦ natural fit for most cloud platforms
  ♦ all Java cloud platforms are capable of running an executable JAR file
  ♦* the Spring Initializr defaults to JAR packaging unless you tell it to do otherwise
• Whereas WAR files are perfectly suitable for deploying to a traditional Java application server
  ♦ needs to include a web initializer class

• "Bootstrapping the Application"                             (pg.12(34))
  ♦ means starting the application's initial setup process
  ♦ This process typically involves:
    1. Loading Core Components: Loading essential classes and libraries into memory
    2. Initializing the Environment: Setting up system properties, environment variables, and configurations
    3. Creating the Main Container: For frameworks like Spring, it means creating the central
    container (like the ApplicationContext) that will manage all other components
• @SpringBootApplication
  ♦ is a composite application that combines three other
 annotations:
    1. @SpringBootConfiguration ,  this annotation is, in fact, a specialized form of the @Configuration annotatio
    2. @EnableAutoConfiguration ,  this annotation tells Spring Boot to automatically configure any components that it thinks you’ll need
    3. @ComponentScan ,  lets you declare other classes with annotations like @Component, @Controller, @Service, and others,
        to have Spring automatically discover them and register them as components in the Spring application context
  ♦ SpringApplication.run() performs the actual bootstrapping of the application, creating the Spring application context
    ○ .run( Configuration Class, Command-line arguments )

Writting a Spring Application
• @Controller ,  general purpose annotation, but used for better descriptiveness
• @GetMapping("/") ,  http get request handler
  ♦ The return value is interpreted as the logical name of a view
• The template for the 'home' view is in src/main/resources/templates/home.html
• Images should referenced with Thymeleaf are written as follows:
   <img th:src="@{/images/TacoCloud.png}"/>
  ♦ Thymeleaf uses th:src attribute and an @{...} expression to reference the image with a context relative path
• Images go in the dir src/main/resources/static/images/TacoCloud.png
• @WebMvcTest ,  is a special test-annotation provided by Spring Boot that arranges for the test to run in the context of a Spring MVC application
(pg.20(42))

• SpringBoot Dev Tools
  comes with:
  ♦ Automatic application restart when code changes
  ♦ Automatic browser refresh when browser-destined resources (such as templates, JavaScript, stylesheets, and so on) change
  ♦ Automatic disable of template caches
  ♦ Built in H2 Console if the H2 database is in use
    ○ Accesible at http://localhost:8080/h2-console , to gain insight into the data your application is working with

Important dependencies and what they offer
• The 'core Spring Framework'
  ♦ is the foundation of everything else in the Spring universe
  ♦ it provides:
    ○ the core container 
    ○ dependency injection framework
    ○ Spring MVC
    ○ some elemental data persistence support, specifically template-based JDBC support
    ○ support for reactive-style programming (Spring WebFlux)
• 'SpringBoot'
  ♦ starter dependencies
  ♦ autoconfiguration
  ♦ the 'Actuator', provides runtime insight into the inner workings of an application
  ♦ flexible specification of environment properties
  ♦ additional testing support
  ♦ Spring Boot CLI,  an alternative programming model based on Groovy scripts
• 'Spring Data'
  ♦ adds the ability to define your application’s data repositories as simple Java interfaces
  ♦ using a naming convention when defining methods to drive how data is stored and retrieved
  ♦ is capable of working with different kinds of DBs like: JPA, Mongo, Neo4j
• 'Spring Security'
  ♦ addresses authentication, authorization, and API security
• ' Spring Integration' and 'Spring Batch'
  ♦  provide the implementation of patterns of application integration
• 'Spring Cloud'
  ♦ a collection of projects for developing cloud-native applications with Spring
  ♦ helps microservices

//• A "repository" ,  is a software design pattern used to manage data persistence
     It acts as an abstraction layer between the application's business logic and the
     data source (like a database, file system, or a remote API)
    ♦ When developers talk about repositories, they're referring to a class or interface
    that handles all the low-level details of how to: Create, Read, Update, and Delete an object

• Domain
  ♦ An application’s domain is the subject area that it addresses—the ideas and
  concepts that influence the understanding of the application
  ♦ Like: +taco designs, +ingredients, +customers, and +taco-orders
•* for Domain classes it's very usefull to make use of 2 special Java feats:
  1♦ Lombok ,  Java library(dependency) that reduces boilerplate code
    ○* all the boilerplate that is normally associated with simple POJOs (Plain Old Java Objects) and beans
    ○ It uses annotations to automatically generate code during the compile phase, such as
      ◘ @Getter ,  creates the getter method to the field
      ◘ @Setter ,  creates the setter method to the field
      ◘ @Data ,  bundles several annotations together
        ◙ Getters: for all private fields
        ◙ Setters: for all non-final fields (these will be set in the constructor)
        ◙ toString(): with @ToString it provides string representation of the object details(fields)
          ♣ it includes the class name and the value of each field
        ◙ equals(): to directly compare objects(automatically does it by value)
        ◙ hashCode(): using the @EqualsAndHashCode annotation
          ♣ it computes a hash code from all the non-static, non-transient fields in the class
          ♣ it's crucial for correctly storing and retrieving objects in hash-based collections like HashMap and HashSet
      ◘ @RequiredArgsConstructor ,  generates a constructor for every final field and every field annotated with @NonNull that is not already initialized

• ENUM
  ♦ (enumeration) is a special data type in Java that allows a variable to be a set of predefined constants
  ♦ The enum declaration defines a class (called an enum type)
  ♦ More Than Just Constants, They are classes under the hood and can have their own fields, constructors, and methods
  ♦ An enum is essentially a class with a fixed number of instances(the Constants) which are public, static, and final
  ♦ key features of enums:
    ○ Type safety: the values cannot be repeated and are checked against l/u-cassing
    ○ Readability: due to the use of named constants
    ○ Versatility: because they're not simple constants. They are classes under the hood and can have their own fields, constructors, and methods
  ♦ ie.:  public enum DayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
            FRIDAY, SATURDAY, SUNDAY }
          //you use it like so:
          DayOfWeek today = DayOfWeek.MONDAY;
  ♦ It can have it's own 'main' method for testing
  ♦ ie.(example with Fields and Methods):
      public enum DayOfWeekWithFields {
        MONDAY(true), TUESDAY(true), WEDNESDAY(true), THURSDAY(true),
        FRIDAY(true), SATURDAY(false), SUNDAY(false);

        private final boolean isWeekday;

        // Constructor for the enum constants
        DayOfWeekWithFields(boolean isWeekday) {
            this.isWeekday = isWeekday;
        }

        // Method to check the value
        public boolean isWeekday() {
            return isWeekday;
        }
      }
  ♦ an enum cannot extend anything else, besides the implicite extend for java.lang.Enum
  ♦ The compiler automatically adds some special methods when it creates an enum:
    ○ A static values() method that returns an array containing all of the values of the enum in the order they are declared
    ○ A constructor for the enum type that must be package-private or private access(by default)
      ◘ It automatically creates the constants that are defined at the beginning of the enum body
         It accepts all final properties as arguments
      ◘* You cannot invoke an enum constructor yourself
      ◘//* Check the Planet.java as a great example for the enum type, with all it's special feats
            run the Planet.class with:  $ java Planet 175  # to get:  Your weight on MERCURY is 66.107583 ...

Controller Creation
•// Logger: software component or utility used to record and output information about a program's execution
  ♦ This information is typically written to a log file, console, or another output stream
• @Slf4j ,  is a Lombok-provided annotation for logger creation
  ♦ at runtime will automatically generate an SLF4J (Simple Logging Facade for Java, https://www.slf4j.org/) Logger in the class
  ♦ this annotation is the same as adding the following line:
     private static final org.slf4j.Logger log =
      org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);
  ♦ It essentially does three things:
    1○ Declares a logger variable: It automatically creates a private static final field named log (or LOG) of type org.slf4j.Logger
    2○ Initializes the logger
    3○ Hides the boilerplate
• @Controller ,  mark the class as a candidate for component scanning
  //so that Spring will discover it and automatically create an instance of the Controller as a bean in the Spring application context
• @RequestMapping("path") ,  specifies the kind of requests that this controller handles
  ♦ Maps web requests to specific methods in a controller class
• @GetMapping ,  specifies that when an HTTP GET request is received for the page specified in the @RequestMapping, the following method will be called to handle the request
  ♦  Prior to Spring 4.3, you might have used a method-level @RequestMapping annota tion instead:
      @RequestMapping(method=RequestMethod.GET)
• Spring MVC request-mapping annotations
  ♦ @RequestMapping    General-purpose request handling
    ◘ can be used specialized, like:  @RequestMapping(value="/path", method=RequestMethod.GET)
    ◘ It's a Class-level annotation that maps all requests whose path begins with /orders to this controller
    ◘ It helps organize your application's endpoints
  /* The following are Method-level annotations
     They are request shortcut annotations:  */
  ♦ @GetMapping        Handles HTTP GET requests
  ♦ @PostMapping       Handles HTTP POST requests
  ♦ @PutMapping        Handles HTTP PUT requests
  ♦ @DeleteMapping     Handles HTTP DELETE requests
  ♦ @PatchMapping      Handles HTTP PATCH requests
• Model ,  is an object that ferries data between a controller and whatever view is charged with rendering that data
  ♦ class imported from org.springframework.ui.Model
  ♦ data that’s placed in Model attributes is copied into the servlet response attributes,
    where the view can find them

View Creation
• Spring options for defining views:
  ♦ JavaServer Pages (JSP), Thymeleaf, FreeMarker, Mustache, and Groovy-based templates
• Thymeleaf ,  
  ♦ View libraries such as Thymeleaf are designed to be decoupled from any particular web framework
  ♦ they’re unaware of Spring’s model abstraction and are unable to work with the data that the controller places in Model
  ♦ But they can work with "servlet request attributes"
  ♦ Thymeleaf-namespaced attribute that perform actions or data binding:
    ○ you use them as attributes of html elements
    ○ th:text , to retrieve text  ->   <p th:text="${message}">placeholder message</p>
       and replaces the text value of the element with the th-text-value
    ○ th:each ,  for iteration  -> ie.:  th:each="itemVariable : collection"
       ie.: <div th:each="ingredient : ${wrap}">
              <input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
              <span th:text="${ingredient.name}">INGREDIENT</span><br/>
            </div>
      ◘ : ${wrap} ,  to render just the list of "wrap" ingredients
    ○ th:value ,   sets the rendered <input> element’s value attribute to the th:value found
    ○ th:href ,  to define href attribute  ->  <link rel="stylesheet" th:href="@{/styles.css}"/>
    ○ th:src ,  to define src attribute  ->  <img th:src="@{/images/TacoCloud.png}"/>
    ○ th:field ,  to define 'name' attribute  ->  <input type="text" th:field="*{name}"/>
      ◘ th:field="*{name-field-inString}"
      ◘ if you use this approach to set the name of any input elm it's fine
        BUT if used for checkboxes, it creates 2 input elements, for some reason...
    ○ th:object ,  ->  <form method="POST" th:object="${design}">
      ◘ Serves as the central model for your form
      ◘ Sets the Context: tells the form to bind its fields to the properties of the design object passed from the Spring controller
      ◘ Facilitates Data Binding: Once the object is set, you can use th:field on form inputs (like <input>, <select>, and <textarea>)
        to bind them to a specific property of that object.
      ◘ Error Handling: It works with Spring's validation framework.
      ◘ If a form submission fails validation, th:object and th:field can automatically display error messages next to the corresponding form fields.
    * another example for the iteration with Thymeleaf:
       //Java file
       model.addAttribute("tacos", List.of(new Taco("Carnitas"), new Taco("Veggie")));
       //HTML
       <ul id="tacoList">
         <li th:each="taco : ${tacos}" th:text="${taco.name}">placeholder to be replaced</li>
    ○ th:if ,  if true what's inside that element will be visible
    ○ th:action ,  mainly used in <form> POST reqs for redirection
      ◘ ie.:  th:action="@{/orders}"  //being displayed in designTaco view
      ◘  @{…} ,  this operator can be used for a context-relative path

• Creating a Static-View Controller for straightforward views, with no data to handle
  ♦ a controller that does nothing but forward the request to a view
  ♦ Typically called a 'WebConfig', this class would implement 'WebMvcConfigurer' interface
  ♦ To add views ,  You need to @Override the addViewControllers method from the interface
  ♦ And with a 'ViewControllerRegistry' class, use the registry objects methods addViewController, and setViewName like so:
  ♦ ie.:  @Configuration                                           //import org.springframework.context.annotation.Configuration;
          public class WebConfig implements WebMvcConfigurer {     //import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {  //import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
              registry.addViewController("/").setViewName("home");
            }
          }

• Template caching
  ♦ By default, templates are only parsed once, when they’re first used, and then cached for subsequent use
  ♦ to disable caching, (for development purposes) you need to set the template caching property to false 
  ♦ ie.(for thymeleaf):  in application.properties add ->  spring.thymeleaf.cache=false
  ♦* be sure to remove that line before deploying to production. Or set it in a profile

Choosing a view Template Library
• Template options supported by Spring Boot autoconfiguration:
    FreeMarker             -  spring-boot-starter-freemarker
    Groovy Templates       -  spring-boot-starter-groovy-templates
    JavaServer Pages (JSP)  -  None (provided by Tomcat or Jetty)   //* is only an option if you’re building your application as a WAR file and deploying it in a traditional servlet container
    Mustache                -  spring-boot-starter-mustache
    Thymeleaf               -  spring-boot-starter-thymeleaf

Model in Java
• A Model is a class that represents a data structure or a real-world object
• It's a core component of the Model-View-Controller (MVC) design pattern
• Its primary purpose is to hold and manage the application's data and business logic
• The model knows nothing about how it will be displayed on a web page or how it will be created from a form
• The org.springframework.ui.Model
  ♦ is a core interface in Spring MVC
  ♦ It's a lightweight, map-like object that acts as a container for data,
    -passing it from a controller to a view-
  ♦ when assigned as method parameter  ->  public String showDesignForm(Model model)
    assigned n called by key value to the view  ->  model.addAttribute("key", "value");
      model.addAttribute("message", "Hello, world!");
      model.addAttribute("user", user);  //user is the whole object with it's instance variables and methods
      view-> ${message}  ${user.name}
• @ModelAttribute ,  Spring annotation to bind data from a web request to a Java object
  ♦ It works in two main ways, depending on where you place it
    1○ As a Method Parameter. (Most common use)IT tell spring to do the following:
      ◘ Create an instance of the specified object
      ◘ Bind data from the incoming request (e.g., form fields) to the object's properties
      ◘ Add this newly populated object to the Model so it can be accessed in the view
      ◘ ie.:
        @PostMapping("/orders")
        public String processOrder(@ModelAttribute Order order) {
          orderRepository.save(order);
          return "redirect:/";
        }
        // The 'order' object is automatically created and populated with form data.
        // It's also added to the model with the key "order".
    2○ As a Method-Level Annotation. When placed on a method
      ◘ It tells Spring to execute that method before any request-mapping methods in the same controller
        The return value of the method is then added to the Model
      ◘ ie.:
        @Controller
        public class DesignController {
            
            // This method will be called before any other methods in this controller.
            @ModelAttribute(name = "ingredients")
            public List<Ingredient> addIngredientsToModel() {
                return ingredientRepository.findAll();
            }
            
            @GetMapping("/design")
            public String showDesignForm() {
                // The "ingredients" list is already in the model and can be used in the "design" view.
                return "design";
            }
        }
•//* ¡¡¡The Model object only exists within the scope of your controller method!!!

DEBUGGING
• In IntellijIDEA
  1♦ Add Run > Edit Configurations... > Remote JVM Debug
  2♦ Use a better name, everything else stays the same
  3♦ It'll listen on port 5005, so you’ll need to run mvn cli
  4♦ In your project terminal run:
    $ mvn spring-boot:run -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"

• In VSCode
  1♦ Install the 'Spring Boot Extension Pack'
  2♦ Click on the SpringBootDashboard button
  3♦ Right click in apps > YourProjectName > debug
  4♦ VSCode Spring Boot extension should take care of the configuration
    ○ It created this config in launch.json:
      {
        "configurations": [
          {
            "type": "java",
            "name": "Spring Boot-TacoCloudApplication<taco-cloud>",
            "request": "launch",
            "cwd": "${workspaceFolder}",
            "mainClass": "com.jalfredev.taco_cloud.TacoCloudApplication",
            "projectName": "taco-cloud",
            "args": "",
            "envFile": "${workspaceFolder}/.env"
          }
        ]
      }
  !♦ DO NOT TRY TO DEBUG STRAIGHT FROM THE 'RUN AND DEBUG' BUTTON, who knows with what it works
  ♦ 'Watch' expressions to check in your controller:
    ◘ model.getAttribute("myObjectKey")

Proccessing form submission
• Important points in form to review/check
  ♦ 'method' attribute - POST, the request
  ♦ 'action' attribute - action or method to be called on submission
    ○ Basically to do a 'redirect'
    ○ Without an action specified, the form would submit an HTTP POST request
      back to the same URL that presented
    ○ So it is used when you want the form to take you to a -different URL-
 the form.
• A controller handler method is needed for that specific POST request
• @PostMapping ,  annotation used to handle POST requests

Validation
• @Valid ,  is an annotation used to validate an object meets all its defined validation
            constraints (like @NotNull, @Size, etc.)ect
  ♦ You need to add the Hibernate Validator and Jakarta EE Validation API dependencies
    with the dependency:  spring-boot-starter-validation
  ♦ And you use it like:
     public String processTaco(@Valid Taco taco, Errors errors) {
        if (errors.hasErrors()) {
            return "design"; // Go back to the form if there are validation errors
        }
  ♦ @Valid tells Spring to check the Taco object for any violations of its validation rules
     perform validation on the submitted Taco object
     before the processDesign() method is called

  ♦ The Errors object is then used to store any errors occurred
• Errors class
  ♦ is an interface in the org.springframework.validation package
  ♦ Crucial Spring MVC tool for handling validation errors that occur during form submissions
  ♦ It works in tandem with the @Valid annotation
  ♦ Each error is represented as an instance of the FieldError or ObjectError class,
    providing information about which field failed and why
Validations:
• @NotBlank
• @NotNull
• @Size
  ♦ @Size(min=5, message="Name must be at least 5 characters long")
  ♦* !!only validates non-null collections
• @Pattern
  ♦ @Pattern(regexp="^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$", message="Must be formatted MM/YY")
  ♦ good site to check for regex exp www.regular-expressions.info
• @Digits
  ♦ ie.:  @Digits(integer=3, fraction=0, message="Invalid CVV")
• @CreditCardNumber
  ♦ comes from:  org.hibernate.validator.constraints.CreditCardNumber
  ♦ must be a valid credit card number that passes the Luhn algorithm check, or "mod 10" algorithm
    ◘ This prevents user mistakes and deliberately bad data but doesn’t guarantee that the credit card 
      number is actually assigned to an account or that the account can be used for charging
• Most come from:  javax.validation.constraints
• //All can have or not values in parenthesis
  Most will be for a specific desired Message, or for more specific validation definitions
  Like for @Size and @Pattern, and @Digits

• Thymeleaf offers convenient access to the Errors object via:
  ♦ the fields property and
  ♦ with its th:errors attribute
  ♦ ie.:   <input type="text" th:field="*{ccNumber}"
            <span class="validationError"
                  th:if="${#fields.hasErrors('ccNumber')}"      <!- if, to show the span elem ->
                  th:errors="*{ccNumber}">CC Num Error</span>

//***
@Size(min=1)
List<> objects are set to null be default, and the @Size looks for [], it doesnt see null
therefor you have 2 options:
  •1  Add a hidden input to your form to set the base value as an empty array
    ♦  <input type="hidden" th:field="*{ingredients}" value="" />
  •2  Add the @NotNull annotation for null scenarios
  • add both for best user experience and robustness


--------------- Chapter 3 - Working with Data ---------------
• To add data persistence an existing Spring support is JDBC (Java Database Connectivity) which to eliminate boilerplate code
• Then you rework the data repositories to work with the JPA (Java Persistence API), to eliminate even more code
• SQL and relational databases are the leading choice for data persistence
• Spring JDBC support is rooted in the JdbcTemplate class, and helps with querying a DB in a simpler form
• To query a DB without help, with raw Java code, your query needs to surrounded by code that creates a connection,
  creates a statement, and cleans up by closing the connection, statement, and result set
• For development purposes you can use an embedded DB, like H2

• Adapting your domain(main objects/tables) for persistence
  ♦ You need a field for a unique identifier : id
  ♦ And created date and time fields

Jdbc Template
• You'll need to create an interface that defines what operations your Domain repository will perform
• ie.:  the Ingredients repo will need to:
        + Query for all ingredients into a collection of Ingredient objects
        + Query for a single Ingredient by its id
        + Save an Ingredient object
• @Repository ,  is a Spring annotation that marks the class as a repository component
  ♦ It's a type of @Component but is more specific for classes that handle data access and persistence
  ♦ Spring's component scanning will automatically detect this class and register it as a bean in the Spring application context
• JdbcTemplate ,  is a core Spring class that simplifies working with databases by handling all the low-level JDBC boilerplate code for you
  ♦ like opening and closing connections, and handling exceptions
• JdbcTemplate's Instance Methods:
  ♦ .query("SQL string query", RowMapper method)
    ○ it returns a single object, specifically used when you expect a single row to be returned
  ♦ .queryForObject("SQL string query", RowMapper method, param)
    ○ it executes a SQL query and returns a list of objects
    ○* SQL query placeholder (?) for a parameter
  ♦ .update("SQL string query", params)
    ○ can be used for any query that writes or updates data in the database
    ○ used for SQL statements that modify the database, such as INSERT, UPDATE, or DELETE
• ResultSet ,  is a Java object that represents a table of data retrieved from a database as a result of executing an SQL query
  ♦ (the current row from the database) and the row number
  ♦ When you execute a query, the data is returned from the database and stored temporarily in a ResultSet object
  ♦ You can then use the ResultSet to iterate through the data, one row at a time
  ♦* The ResultSet object maintains a cursor pointing to the current row
  ♦ Key Characteristics:
    ○ Cursor-Based: You move the cursor through the data using methods like next(), which advances the cursor to the next row
    ○ Column Access: ou can retrieve the data from a specific column of the current row using various getter methods, such as getString(), getInt(), or getDate().
        You can specify the column either by its index (starting from 1) or its name.
    ○ Read-Only: By default, a ResultSet is read-only
    ○ Automatic Closing: The ResultSet is a resource that needs to be properly closed to free up database connections.
      However, JdbcTemplate in Spring handles this automatically for you, which is one of the main reasons it's so popular.
  ♦ in simple: a ResultSet is the raw, tabular data that comes directly from your database,
    and it's the job of a RowMapper (or a similar mechanism) to read this data and convert it into a Java object

Logic
• Iterable interface:  is a core part of the Java Collections Framework
  ♦ it's not a class, but an interface that represents a collection of elements that can be iterated over
  ♦ Any class that implements the Iterable interface must provide an iterator() method
    ○ This method returns an Iterator object, which is then used to traverse the elements one by one
  ♦ Use like:  Iterable<Ingredient> findAll();
    ○ means the method will return an object that you can iterate over
    ○ and each item in the sequence will be an Ingredient
    ○ it promises to return a collection, it not specifying which one
• @Autowired ,   is a Spring annotation for dependency injection
  ♦ used when you have >1 constructors and creates the base constructor with all the class fields
• this::mapRowToIngredient ,  This is a method 'reference'
  ♦ It's a shorthand for a lambda expression that simply calls a single method
  ♦ it means you are passing a REFERENCE to the method itself as an argument,
    -not the result of executing it-
  ♦* Method references are most commonly used when working with Java 8 Streams and functional interfaces,
     like a RowMapper in Spring's JdbcTemplate

♣ the IngredientRepository interface
  ♠ we need it to define the operations needed for the model-controller as method declarations
  ♠  you’ll still need to write an implementation of IngredientRepository that uses JdbcTemplate to query the database




//***
• A checked exception ,  is a type of exception in Java that must be handled by the programmer at compile time
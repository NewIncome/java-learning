Spring Rest API development
----------------------------
by Devtiro
https://www.youtube.com/watch?v=Nv2DERaMx-4

► Coding Steps
---------------
1- https://start.spring.io
2- Dependencies add: "Spring Web"
3- 


► Maven Concepts
-----------------
• Apache Maven
  ○ Helper to manage projects and all needed to build, test, package-it
  ○ MVN has 3 main phases or Life-cycles, with certain goals in each
    ♦ each name is also the mvn command to be used
    ♦ clean   - remove temp dirs and files
      ◙ pre-clean   - hooks for before cleaning
      ◙ clean       - the actual cleaning
      ◙ post.clean  - hooks for after cleaning
    ♦ 2. default - where most useful goals live
      //* if called 'default' it will run the goals in order
      ◙ compile   - compiles code into bytecode
      ◙ test      - runs unit tests
      ◙ package   - creates a jar or war file
      ◙ verify    - runs checks and integration tests
      //* if you run a specific goal-command, it'll run the previous goals
    ♦ 3. site    - where documentation is generated

  ○ 'target' directory
    ♦ is where all th eproject is actually being built
    ♦ which is what gets cleaned out in the 'clean phase'
  ○ 'src/main/resources/application.properties
    ♦ this is where we would configure our app
     ie.: with other file to load etc.
    ♦ the Tests dir also has a the same dir/file for config

  ○ Commands while developing
  // $ mvn clean test  //is a good way to make sure everything is ok before testing
  // $ java -jar restapi-0.0.1-SNAPSHOT.jar  //to run the compiled file as we would in production. And can bee seen as if run normally; port 8080
      this being inside the target/ directory
  // $ mvn spring-boot:run
    ♦ clean > compile > run/test
  // $ mvn package
  // $ java -jar <name of created project .jar file>
      to run project from the final packaged .jar file, this with envVars


► Spring Framework
--------------
By itself is highly configurable, but a lof of work
• LAYERS
  ♦ Presentation ,  use all the data from the 'Service layer' and expose it to the user
    ◙ with a RestAPI which uses controllers for implementation
      or a GraphQL-API, or WebSockets-API
  ♦ Service ,  use all of the functionality exposed by the 'persistence layer'
      and use it to meet the requirements our application is built to handle
    ◙ with Services
  ♦ Presistence ,  handles interactions with our DB
    ◙ with Entities
    ◙ with Repository patterns, and DAO's patterns (DataAccessObject) - CRUD


► Spring Boot
--------------
Is a layer built on top of -Spring Framework-
• Puspose is to provide additional functionality
• Helps managing and creating Beans and Interfaces, by sensible defaults

▲ IOC, DependencyInjection
• What the Framework does? Provides and injects the classes/dependencies/Beans
• We just need to make the Interfaces for our main class
• Ways of configuring Beans:
  ♦ by the @Configuration class
  ♦ by the @Component annotation (& friends)

▲ Component Scanning
Is a process that starts when your application starts up
• Spring Boot will look through your project
  ♦ It's going to look for Beans and where Beans are needed (in the constructor of a Bean)
• Then it adds them as Beans to the Spring App Context
• If it has dependencies it'll look for them in the context, and add them where they're needed
  ♦ That process is called 'Dependency Injection', and also 'Autowiring'(more Spring specific term)
• Traditionally an @ComponentScan annotation declared the start of the startpoint of the Beans to scan and forward down the tree
  ♦ but now it's done by @SpringBootAplication annotation

▲ The @SpringBootAplication annotation
Is an alias for many other different annotations
• the main 3:
  1. @Configuration ,  identifies a configuration class
    ◙ which is a place to look for Beans during the ComponentScanning phase
  2. @ComponentScan ,  sets the hierarchy point
    ◙ to, from that point down, look for Beans and places that Beans are needed
  3. @EnableAutoConfiguration ,  provides all the sensible-defaults that make SprintBoot great
    ◙ also adds create all needed and set Dependencies

▲  @EnableAutoConfiguration
• the SpringBootStarters are a collection of the Dependencies above mentioned
  ♦ one is for example 'SpringWeb' == spring-boot-starter-web
    ◙ which is a collection of dependencies needed to implement a web project
    ◙ like: SpringMVC and embeddedTomCat

• pom.xml file ,  is where all out dependencies can be found

//* Specially used annotations:
   ○ @ConditionalOnClass({ClassName.class}) ,  when the {class} is available on the class path,
     the following class should be instantiated and run
   ○ @ConditionalOnBean(Bean) ,  when this bean is available the following part of the config/code should be run
   ○ @ConditionalOnMissingBean(Bean) ,  run the following code when the Bean is missing


▲  Configuration Files to Set "Sensible Defaults"
1• We have the src/main/resources/application.properties file
  ♦ where we can set some special properties like: server.port=8181
  ♦ We can find docs for all in: https://docs.spring.io/spring-boot/appendix/application-properties/index.html
  ♦ Also, if we desire another code format, we can rename the file to:
    application.yml
    ◙ with that name our format would be:
      server:
        port: 8181
• We can also have this file for Tests, in test/resources/application.properties
2• Do this with Environment Variables:
  ♦ SERVER_PORT=8181
  ♦ This can be done at time of running maven
    $ SERVER_PORT=8080 mvn spring-boot:run
  ♦ Or set in temporary env variables in that terminal session
    $ export SERVER_PORT=8080
    Then run the application normally, it will pick up the env variables automatically
3• We can also use @ConfigurationProperties annotation
  ♦ which also needs the @Configuration annotation put first
    ◙ to tell Spring to look at that class to look for Beans, for config
  ♦ Then in your application.properties you can have the variables to be picked up like:
    pizza.sauce=bbq
    //and in the code:
    @Configuration
    @ConfigurationProperties(prefix="pizza")
    public class PizzaConfig { private String sauce }
    //that code to be then injected(say via ConstructorInjection) to the main class for use


► DataBase and DataBase Layers
• Database Driver - allows to interact with the DB from your java code
• JDBC (JavaDataBaseConnectivity) - LowLevel API, for sql queries
• Spring JDBC - adds spring magic to normal JDBC with 'templates'
• JPA (JavaPersistenceApi) - Allows interaction with DB by JavaObjects
  ♦ is also built on top of JDBC, so considered a HighLevel API
  ♦ technically JPA is a specification
  ♦ the implementation in Spring is done by 'Hibernate'
• Spring Data JPA - adds spring magic, such as defined repositories
• Hibernate is an ORM

▲  H2 in-memory DB
• You just connect to it by
  ♦ injecting a DataSource dataSource dep
  ♦ creating a new JdbcTemplate(dataSource)
  ♦ and using the JdbcTemplate like:  restTemplate.execute("select 1");
• You can configure it if desired in the application.properties file with:
  ♦ spring.application.name=database01
    spring.datasource.url=jdbc:h2:mem:testdb
    spring.datasource.driverClassName=org.h2.Driver
    spring.datasource.username=sa
    spring.datasource.password=password
• for Testing, also has some specific settings to allow it to emulate quircks of some databases(like postgres)
  ♦ ie.:  spring.datasource.url=jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    ◙ jdbc:h2:mem:testdb
    ◙ MODE=PostgreSQL ,  to emulate postgres
    ◙ DATABASE_TO_LOWER=TRUE ,  to set everything to lower-case to replicate postgres behaviour
▲  with PostgreSQL and other DB's
• the Java code will be exactly the same
• the difference will be in the configuration, in application.properties
• then you just need to run/start the DB and it should work
  ♦ you can do so with docker

• View on DBeaver, graphical view of DB's
  ♦ keep open the DB connection (easier with Docker-compose)
  ♦ open in same port
  ♦ add password
  ♦ test connection
  ♦ finish
• you can view it in the path:  postgres > Databases > postgres > Schemas > public > Tables > "tableName"
  ♦ double click there, then selec tab 'Data' to view the info in the table
  ♦ or 'ER Diagram' to view the column names

* 1:17:00 ,  Interesting short code, pizza proj
  + uses well structured String.format
  + uses @Log, and @Data annotations (also @AllArgsConstructor, @NoArgsConstructor)
  + uses "lombok"(Logger), ... , has great annotations that automate code ...

▲ JdbcTemplate and DAO pattern(Data Access Object)
• DAO ,  objects that reference and map to tables in a DB
• Those Dao's start being interfaces
• Those interfaces need implementations
  ♦ those will 'always' need the JdbcTemplate
• @Configuration ,  Declares that a class is a source of Bean definitions
  ♦  It tells the Spring container that this class contains one or more @Bean methods that Spring should process and manage
  ♦* Sets like the 'Database Setup Blueprint'
• @Bean , Marks a method whose return value should be registered as a Bean in the Spring application context
• @Builder , It's purpose is to automatically implement the Builder Design Pattern for your class
*** The Builder pattern
  + is a creational design pattern that allows you to construct complex objects step-by-step using a fluent, readable API
  + generates all the necessary code for this pattern, including:
    > A static inner class (the actual "Builder")
    > A static builder() method on the main class that returns an instance of the inner builder
    > Methods on the builder class for each field
    > A build() method that creates and returns the final object
  + Solves the "Telescoping Constructor" Problem:
    > When a class has many optional fields, you would traditionally need
      to write a long, tedious constructor with all possible parameters
      (or many overloaded constructors). The builder pattern, and thus
      @Builder, solves this by allowing you to set only the fields you need,
      in any order.
  +* Facilitates Immutable Objects
    > Commonly used to construct objects where all fields are final
    > Since all values are passed to the builder before the object is created (when build() is called),
      it's the ideal tool for creating fully immutable objects
•• SetUp
 ♦ The "Configuration Class way"
  ◙ creating a configuration class to define all our beans that'll there be registered to the Spring Application Context
  ◙ ie.:  config/DatabaseConfig.java  //(class) with many Contructor injected Beans
• Base files:
  1♦ Domain ,  class files for our Models / objects - to replicate DB tables
  2♦ DAO's ,  interfaces that will be blueprint for the actions/methods performable to those
  objects(the domain)
  3♦ Implementations(impl's) ,  classes that will implement the DAO's interface methods
• Test configuration
  ♦ add the H2 DB with the scope of 'test', in the pom file
  ♦ set-it-up in the test/resources/application.properties file

▲ Test Driven Development (TDD)
•> Steps to a Create UNIT test:
  1♦ Create the dao/AuthorDaoImplTests file
  2♦ then test testThatCreatesAuthorAndGeneratesCorrectSql()
    ◙ create an Author with Author.builder().build();  ie.: ...builder().id().name()...build();
  3♦ then declare the AuthorDao interface create() method
  4♦ then create the AuthorDaoImpl create() method, empty
  5♦ then assert the test with argument matchers
  6♦ then run the test, it should fail
  7♦ then populate the AuthorDaoImpl create() method
  8♦ then run the test, it should pass Ok
('till 2:02:00)
• @ExtendWith(*.class) ,  is a repeatable annotation that is used to register extensions for the annotated
    test class, test interface, test method, parameter, or field
  ♦ Annotated parameters are supported in test class constructors, in test methods, and in
    @BeforeAll, @AfterAll, @BeforeEach, and @AfterEach lifecycle methods.
  ♦ @ExtendWith fields may be either static or non-static
  ♦ (*.class) ,  are sort of help classes that will be registered as extensions
    ◙ It have many with repeated @ExtendWith annotations
  ♦ @ExtendWith(MockitoExtension.class)
    ◙ This annotation integrates Mockito with JUnit 5
    ◙ It enables Mockito to initialize mocks and inject them into the test class
• @Mock ,  this Mockito annotation creates a mock(fake) object of 'the JdbcTemplate class for example'
  ♦ A mock is a fake object that simulates the behavior of the real JdbcTemplate
• @InjectMocks ,  this annotation tells Mockito to create an instance of 'AuthorDaoImpl for example'
  ♦ and automatically inject the mocked jdbcTemplate into it
  ♦* Typically, 'AuthorDaoImpl for example' has a dependency on JdbcTemplate(the class annotated with Mock)
  ♦ and Mockito handles this dependency injection for the test
• @Test ,  is used to signal that the annotated method is a test method
  ♦ This JUnit 5 annotation marks the method as a test case
  ♦ body structure:
    public void testThatCreateBookGeneratesCorrectSql() { //descriptive method name
        Author author = Author.builder().id(1L).name("Abigail Rose").age(80).build(); //build the obj
        underTest.create(author);   //create(db access to set) the obj

        verify(jdbcTemplate).update(
        eq("INSERT INTO authors (id, anme, age) VALUES (?, ?, ?)"),
        eq(1L), eq("Abigail Rose"), eq(80));
  ♦ verify(jdbcTemplate): This Mockito method checks whether a specific interaction occurred
    with the mocked jdbcTemplate
    ◙ Verifies certain behavior happened once
    ◙ verify(mock, times(1)).someMethod("some arg");
      ◘ the 'times()' parameter is optional, and default to 1
  ♦ .update(...): It verifies that the update method of jdbcTemplate was called exactly once
    with the specified arguments
  ♦ eq(field_data): Argument matcher used to match with specific field data
• The Builder pattern
  ♦ is like a helper that lets you build an object step-by-step
  ♦ It is a design pattern that makes it easier to create complex objects
with many fields or optional parameters in a clean, readable, and flexible way.
  ♦ It’s especially useful when you want to avoid messy constructors with lots of arguments or
    when some fields are optional.
  ♦ .builder() ,  inner class to set the fields one at a time
  ♦ .build() ,  method to create the final object
  ♦ Avoids Constructor Overload
    ◙ if you might need multiple constructors for different combinations, the Builder pattern uses
    one clear way to set any combination of fields
• org.mockito.ArgumentMatchers
  ♦ Allow flexible verification or stubbing
•> Steps to create INTEGRATION tests
  ♦ in this case to run the sql agains an in-memory DB
• @SpringBootTest ,  to startup a test version of our application when our test runs
  ♦ This Spring Boot annotation is used for integration tests.
  ♦ It sets up a full Spring application context, loads beans, and enables Spring-specific
    features like dependency injection and transaction management.
  ♦ Importantly, @SpringBootTest already includes @ExtendWith(SpringExtension.class) as part
    of its implementation (via its meta-annotations)
  ♦** Here a Constructor for ConstructorInjection is necessary
    ◙ AND it's necessary that it uses the @Autowired annotation
    ◙* It's necessary to write the ConstructorInjection method and use the @Autowired annotation because:
      ◘ in Tests beans are not managed like the Spring Application, that's why you can't use @*ArgsConstructor
      ◘ And @Autowired is convention in integration tests
•* @Transactional ,  it wraps the test in a database transaction and rolls back all database changes(by default)
      (e.g., inserting authors or books) after each test, ensuring a clean database state for subsequent tests
  ♦ the default behaviour is configurable with @Transactional(rollback = false)
  ♦ Can specify transaction propagation, isolation levels, and timeouts (e.g., @Transactional(propagation = Propagation.REQUIRES_NEW))
  ♦ Purpose: Manages database transactions and rollbacks
  ♦ Scope: Database operations within a test
  ♦ Performance Impact: Minimal, as it only manages transactions
• @DirtiesContext ,    Marks a test as "dirtying" the Spring application context, forcing Spring to recreate the context for subsequent tests
  ♦ Ensures that context modifications don’t affect other tests, preventing test interference
  ♦ from org.springframework.test.annotation.DirtiesContext
  ♦ Spring caches the application context between tests for performance
    If a test modifies the context (e.g., by changing bean definitions, configurations, or
    in-memory database state), @DirtiesContext tells Spring to discard the current context and
    create a fresh one for the next test
  ♦ Supports different scopes for context invalidation
    (e.g., @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD) orClassMode.AFTER_CLASS)
  ♦ Purpose: Use @DirtiesContext when a test alters the Spring application context (e.g., bean definitions,
    properties, or shared resources) and you need to ensure a fresh context for other tests to avoid side effects
  ♦ Scope: Spring application context state
  ♦ Performance Impact: Higher, as recreating the context is resource-intensive
    ◙ thus, avoid overusing, use it only when necessary (e.g., when shared resources or beans are modified)
  //♦* In some cases, you might use both annotations in a test
▲ Assertions
• assertThat(queryResult) ,  used to assess a result of a query operation(like find*)
  ♦ therefor it is used upon a Collection of elements like: List<>, Optional<>, Iterable<>
  ♦ it has many sub-implementations like:
    ◙ matches(b), isEqualTo(b), isNull(), isNotNull(), isEmpty(), isPresent(),
      .hasSize(i), contains(obj,...), and many more..
  ♦ these assertions can be sequential, or added one after another in one assertThat()
• •* CustomQuery's WITHOUT implementation!!!
  ♦ Spring JPA is able to workout(auto-implement) custom queries based on just:
    -how you name your methods-
    -and the correlation of the methodParam vs the instanceVariables in the Object at hand
      ◙ ie.:  Iterable<Author> ageLessThan(int age);  //declaration, no manual implementation
                //propertyLessThan(T Object.property)
              Iterable<Author> result = underTest.ageLessThan(50);  //usage

▲ CRUD (Create Read Update Delete)
• C - create
• R - read. There are typically 2 ways of doing it:
  ♦ read one obj ,  and look for it by 'id'
    ◙ if no object is found return null typically or empty
  ♦ read many ,  and either show a large list
                      show a filtered sub-set of the list
    ◙ if no objects show in the list show an empty list

• Optional<ObjectClass>
  ♦ used to get an Optional obj back from a query if nothing is found, instead of getting null
  ♦ A container object which may or may not contain a non-null value
  ♦ If a value is present, isPresent() returns true
  ♦ If no value is present, the object is considered empty and isPresent() returns false
  ♦ when crud method auto-generated from interface to implementationClass it comes with:
      return Optional.empty();
• Optional class 'n methods
  ♦ Optional.ofNullable(T value) ,  returns an optional describing the given value
  ♦  .ifPresent(action) ,  if a value is present performs the given value

▲ RowMapper
• Used to convert from a ResultSet and convert it into an object
  ♦* Also used to query a DB with a defined object structure
• ResultSet ,  is whats returned when querying a database
• Because we are using Jdbc and DAO pattern,
  we need to handle the conversion to-and-from SQL and Java objects our selfs
  For this we can use RowMappers, ResultSetExtractors, RowBackHandlers
• Querying a DB with JdbcTemplate and RowMapper, to get a list of objects
  ♦ List<Author> list = jdbcTemplate.query(String sql, RowMapper<Author> rowMapper, @Nullable Object... args)

(now at 2:34:00)
(now at 3:05:00)

► JPA and Hibernate
JPA is a Higher-level API, and takes care of a lot of the lower level details for you
• eg.: we don't need to touch SQL queries with this module

// //feat: Steps to transform from using Jdbc to Spring JPA Data implementation
Changes regarding files and directories
1. Remove schema.sql file. Hibernate will take care of that for us
2. Remove all the DAO's(Author&Book Dao's and Implementations, the whole dir). All the SQL will be generated by JPA
3. Remove the config/DatabaseConfig file. It inyected the JdbcTempalte as the DataSource
4. Remove UnitTest files. And create repositories dir
5. Move the Integration tests to the repositories dir/package
6. Remove the test/Dao dir
7. Comment out all the Integration tests meanwhile
8. Add the JPA dependency in the pom, and remove the Jdbc dependency
Changes regarding new dirs, files
9. Create the package repositories/
  ○ with the interfaces AuthorRepository and BookRepository
  //typically Repositories are not tested because the Dependency does the implementations already
*10. Update our Data/Domain AccessObjects(DAO's) or POJOS(PlainOldJavaObject) to become ENTITIES
• to convert the POJOS into Entities:
  ♦ @Entity ,  label object as an Entity that can be used with Soring Data Jpa
  ♦ @Table(name = "authors") ,  to define which table it maps to in the DB
  ♦ @Id ,  to define the field as the PrimaryKey of the entity/table
  ♦ @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "author_id_seq")
    ◙ Used to auto-generate id's(numeric values starting from 1)
    ◙*  This tells JPA:
        - “Use a database sequence named author_id_seq to generate IDs for new Authors.” -
        //If you manually set .id(1L) in your test data, Hibernate sees that and thinks:
          - “This Author already exists (it already has an ID), so I should update it, not insert it.” -
• @ManyToOne(cascade = CascadeType.ALL) ,  to specify the relationship with the ForeignKey
  ♦ and to be able to get the authorObj when we call the bookObj

▲ Hibernate Auto DDL
Help to setup the schema for you
• DDL stands for Data Definition Language
  ♦ DDL commands are used in SQL to manage the structure and schema of the database
  ♦ The most common DDL operations are:
    ◙ CREATE (tables, indexes, etc.)
    ◙ DROP (delete tables, indexes, etc.)
    ◙ ALTER (modify table structure)
• in resources/application.properties add
  ♦ spring.jpa.hibernate.ddl-auto=update
    #so our schema is updated when we change our Entities
• To try it you can start your DB in docker, run DBEAVER, check the tables
  ♦ and also you can check the 'sequences' setup in the same dir as your tables
  ♦ sequences setup using the @GeneratedValue annotation

Create end-point and ReadOne
• With JPA ENTITES you don't need to make the implementations(for CRUD func)
  ♦ it's done by extending your entity interface with CrudRepository<ObjType, IDtype>
  ♦ ... extends CrudRepository<Author, Long> {..}
• JPA's CrudRepository<T ID> interface adds many method implementations like:
  //♦ can be seen in the org.springframework.data.repository.CrudRepository interface
  ♦ save, saveAll, existsById, findById, findAll, findAllById, count, deleteById
    delete, deleteAllById, deleteAll
  ♦ Is an Interface for generic CRUD operations on a repository for a specific type
  ♦ Methods exposed through this interface allow entities to participate in lifecycle events,
    and optimistic locking if applicable except for some bulk operation methods

@Slf4j
a logger from Lombok
• to use it:
  ♦ log.info();

▲ HQL (Hibernate Query Language)
• is a powerful, object-oriented query language used in Hibernate, an ORM (Object-Relational
  Mapping) framework for Java.
• It allows developers to write database queries using entity names and their properties
  instead of raw SQL tables and columns
• It supports operations like SELECT, INSERT, UPDATE, DELETE, joins, aggregations, and
  subqueries, with syntax similar to SQL but focused on Java objects
• @Query
  ♦ used If you can't do a simple query and you do need to add some Query using HQL
  ♦ Is part of the Java Persistence API (JPA), is used in Spring Data JPA or other JPA
  implementations to define custom queries directly on repository methods.
  ♦ Supports both JPQL (Java Persistence Query Language, similar to HQL) and native SQL queries
  ♦ when using a native query, a @NativeQuery variant is available

► Jackson and JSON
• Jackson ,  popular library for dealing with json in Java and Spring
  ♦ At it’s core Jackson is there to turn a Java object and turn it into JSON,
    through a process called "Marshalling"
  ♦ and then do the opposite, convert json and put it into a Java object called "Un-marshalling"
• Jackson & Spring Web
  ♦ when already added as a dependency, it automatically detects sent Objects (via Requests),
    (sent asString()!)and converts them into json before sending it/them
    ◙ and the other way around, it detects the received json,
      and converts it into an expected Object
  ♦ No additional annotations nor code needed
• Manual conversion:
  ♦ with ObjectMapper class
  ♦ from objectToJson, we use ObjectMapper class, with the .writeValueAsString(Object) method; like:
    ◙ Test example:  //the test will ask for:    throws JsonProcessingException
       ObjectMapper objectMapper = new ObjectMapper();
       Book book = TestDataUtil.createTestBook(); //for this example's sake
       String result = objectMapper.writeValueAsString(book);
       assertThat(result)
         .isEqualTo(
             "{\"isbn\":\"978-0-13-478627-5\",\"title\":\"The Enigma of Eternity\",\"author\":\"Aria"
                 + " Montgomery\",\"year\":\"2005\"}");
  ♦ from objectToJson, we use ObjectMapper class, with the .readValue(jsonString, Object.class) method; like:
      ◙ Test example:
         String json = "{\"isbn\":\"978-0-13-478627-5\",\"title\":\"The Enigma of"
             + " Eternity\",\"author\":\"Aria Montgomery\",\"yearPublished\":\"2005\"}";
         final ObjectMapper objectMapper = new ObjectMapper();
         Book result = objectMapper.readValue(json, Book.class);
         assertThat(result).isEqualTo(book);
•// the jsonString_Attributes must match the instanceVariable_Names, and viceversa
• @JsonProperty annotation
  ♦ to a different instanceVariable_Name than the one defined, to the json Object, and viceversa
  ♦ this, to not modify the existing variable names
  ♦ to be used in our DomainObject class field declarations
• @JsonIgnoreProperties(ignoreUnknown = true)
  ♦ class based annotation
  ♦ used to ignore(not blow up) when additional values come in the Json String

► REST API Design | Structure
• -It is built on the concept of RESOURCES-
  ♦ -the URL structure, is all about Resources-
• Design Steps:
  1♦ Step 1: Establish what Resources we're going to use
    ◙ for now: Books, and Authors
  2♦ Step 2: Define where to -Persist- those Resources
    ◙ for now: PostgreSQL Database
  3♦ Step 3: Build a Service-Layer
  4♦ Step 3: Build a Presentation-Layer
• Our CRUD EndPoints (routes) for Book
  ♦// the object in the URL is in plural by convention
   PUT     /books/{isbn}   //Create 1 book; response->HTTP:201 + bookJson
   GET     /books/{isbn}   //Read 1 book; response-> HTTP:200 + bookJson
   GET     /books          //ReadMany books; always response-> HTTP:200 + emptyList || bookListJson
   PUT     /books/{isbn}   //Update; response-> HTTP:200 + bookJson
   PATCH   /books/{isbn}   //PartialUpdate; response-> HTTP:200 + bookJson
   DELETE  /books/{isbn}   //Delete; response-> HTTP:204 + noBody
  ♦// status 200 for success, and the json response for GETs
      status 201 for success in Creation
      status 404 for failed
  ♦//* PUT is used for the creation because WE are providing the id:isbn instead of the DB-byAuto
        POST is used when the system(DB) generates the ID's
  ♦//* PUT requires AllOfThe_Attributes of the Objetc, and updates the entire Object
        PATCH updates only the attributes you provide
• Our CRUD EndPoints (routes) for Author
*  POST    /authors        //Create 1 author; response->HTTP:201 + authorJson
   GET     /authors/{id}   //Read 1 author; response-> HTTP:200 + authorJson
   GET     /authors          //ReadMany authors; always response-> HTTP:200 + emptyList || authorListJson
   PUT     /authors/{id}   //FullUpdate; response-> HTTP:200 + authorJson
   PATCH   /authors/{id}   //PartialUpdate; response-> HTTP:200 + authorJson
   DELETE  /authors/{id}   //Delete; response-> HTTP:204 + noBody

▲ Presentation Layer
• with/thanksTo spring-boot-starter-web
• Typically done with the Controller Pattern
  ♦ just means the Presentation Layer is built and called upon by controllers
• @RestController
  ♦ class level annotation needed to start creating a RestAPI Controller,
    resfull(that'll work with crud functionality)
• @PostMapping(path = "/authors")
  ♦ method level annotation, to define a method that will make a POST:HTTP request
  ♦ to Create 1 object, in this case in the DB, with an auto-Id
• @RequestBody
  ♦ tells spring to look at the httpRequestBody for the AuthorObj represented as json
  ♦ public Author createAuthor(@RequestBody Author author)
• ResponseEntity<ReturnedObject>
  ♦ Extension of HttpEntity that adds an HttpStatusCode status code.
    Used in RestTemplate as well as in @Controller methods.
  ♦ class used as a Wrapper, it allows to control parts of the response and/or header,
    like the StatusCode of the response
  ♦ syntax:  constructor: ResponseEntity(@Nullable T body, HttpStatusCode status)
  ♦ ie.(in a @PostMapping return stmnt):
     return new ResponseEntity<>(authorMapper.mapTo(savedAuthorEntity), HttpStatus.CREATED);
• @PutMapping("/books/{isbn}")
  ♦ method level annotation, to define a method that will make a PUT:HTTP request
    + for a FULL-UPDATE or CREATE(w-CustomId)
  ♦ to do a FullUpdate of 1 object(or create it if non-exitent), in this case in the DB, with a specific ID
• @PathVariable
  ♦ annotation to get a var-value from the Path/Params
  ♦ Annotation which indicates that a method parameter should be bound to a URI template variable.
    Supported for RequestMapping annotated handler methods.
  ♦ Syntax:  @PathVariable("varName") Type varToAssignValueTo
  ♦ ie.:  @PutMapping("/books/{isbn}")
          public ResponseEntity<BookEntity> createBook(@PathVariable("isbn") String isbn)

▲ Service Layer
• to link together the Persistence-Layer and the Presentation-Layer
• typically worked in a "services" package (dir /services)
• And Typically done by:
  ♦ interfaces to state the actions/methods to be used in the controller

//• Right now our Author is an Entity,
    + which is an object that should only exist in OUR Persistence-layer
    + and maybe our Service-layer, but go no further than that
    + our Presentation-layer should have no knowledge of how our Persistence-layer works
      * One approach is to use a DTO (Data Transfer Object)
*       + which would create a "Mapping-layer" in between to link Presentation+Persistence
        + those DTO's are typically located in /domain/dto package
        + and are POJOS
        + those POJOS will typically need these annotations:
          - @Data
          - @AllArgsConstructor
          - @NoArgsConstructor  //needed for Jackson
          - @Builder
      //* Jackson will create an object using a -NoArgsConstructor-, and then
          use setters and getters to set the values on the object
        + it should look exactly like the Entity(as for the fields),
          without the domain-Author DB 'persistence' annotations

*** A common and debatable issue when separating layers is how much???
• ie.:  in the Controller-Post-createAuthor() method, what object to use?
        - in our case we'll use AuthorDto(interface)-injectedObject as the intermediary
    /* It's ok for the Service-layer to deal with Entities, it's your business logic
       so some knowledge of the underlying entities that the persistence layer uses
       It's debatable and up to the Coder
       But a rule is to definitely seperate the Presentation, Service & Persistance layers
     */
• Now, to map one to the other, AuthorEntity-to-AuthorDto
  ♦ it could be done manually, byt there are libraries that do this for you
  ♦ like the ModelMapper library, used for Object mapping
    ◙ to have access to the ModelMapper(in ApplicationContext), to be called via config/MapperConfig class
    ◙ to use it, we add a package and /mappers/Mapper interface
      *To encapsulate all of the logic for mapping all our application
      ◘ we can implement that interface with Beans, then inject those beans when/where needed
        That allows us to swap things out
        * And we'll need an AuthorMapper for Implementations
►*** NestedObject CRUD functionality
• in this DomainDrivenDesign option, using "JPA, Jackson, and ModelMapper",
  the issue relies in the ModelMapper
  So to have that *functionality all we need is to add a configuration to the MapperConfig
*by functionality I mean, creating a Book, and adding the nestedAuthor's info,
 and without any extra code having SpringDataJPA create both the book and the Author for us
  ♦ so, in the ModelMapper @Bean, instead of just returning a 'new ModelMapper()'
    we, create that modelMapper with the constructor, and add a configuration to it
  ♦ more clearly, add a "Matching Strategy" of "Loose" to it, then return it
  ♦ like so:
     @Configuration
     public class MapperConfig {
       @Bean
       public ModelMapper modelMapper() {
         ModelMapper modelMapper = new ModelMapper();
  >>     modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.LOOSE);
         return modelMapper;
       }
     }
• That is all we need to do, to let "Jackson -> ModelMapper -> SpringDataJPA" handle
  NestedObject CRUD functionality for us!!!

▲ Spring Boot Application Architecture : Layers
• Three tier(or 3 layer) Arquitecture
  ♦ Controller Layer:      Rest API logic
  ♦ Service Layer:         Business logic
  ♦ DAO(Repository) Layer: Persistence logic, or DB logic
• DTO's: are used to transfer data between client(Postman) and server(Controllers-to-DB)

▲ *** Trying to understand this layered architecture
• HttpRequest  >=>  objDTO      >=>  objEntity  >=>  objService  >=>  toDB
•  fromDB      >=>  objService  >=>  objEntity  >=>  objDTO      >=>  HttpRequest

*** Class that implements the "CrudRepository interface" methods
public class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID>

▲ Send HTTP requests via terminal (with CURL)
•GET:  This type of HTTP request is for retrieving data
• GET request
   $ curl https://crawlbase.com
   $ curl http://httpbin.org/get  #Curl defaults to get so you don't need to specify it
• GET and save output/response to a file
   $ curl -o output.html https://example.com
• GET with params
  ♦ Opt1: Using the -G and -d Options
    $ curl -G -d "param1=value1" -d "param2=value2" http://httpbin.org/get
    ◙ -G , option allows you to send data with a GET request
    ◙ -d or --data , option specifies the parameters
  ♦ Opt2: Appending Parameters to the URL
    $ curl 'http://httpbin.org/get?param1=value1&param2=value2'
• GET and fetch JSON Data
   $ curl -H "Accept: application/json" http://httpbin.org/get
   ♦ -H or --header, to specify an action in the header: JSON data to be received
     ◙ For multiple headers you can repeat the -H flag as many times as necessary
• GET with redirect as a response
   $ curl -L http://httpbin.org/redirect-to?url=http://httpbin.org/get
   ♦ -L or --location , option
//♦ --data-urlencode , option, alone or w-param. This approach ensures proper URL-encoding of query strings
     ie.:  --data-urlencode "query=keyword"
• GET and include headers with response
   $ curl -i http://httpbin.org/headers
• GET with just headers no body
   $ curl --head http://httpbin.org/headers
//*for project:
    curl -i -H "Accept: application/json" http://localhost:8080/authors
•POST:  This type of HTTP request is for creating a new entry in a database
• POST simple, 2 params
   $ curl -d “name=Alex&course=Unreal” -X POST http://localhost:3000/api/people
  ♦ -d , to specify the next code will be data
  ♦ -X , to specify the next code will be the type of request
  ♦// Because we have 2 properties of our object, we enclose them in double quotation marks “”
• POST Request sending JSON data
   $ curl -d '{"name":"Abigail Rose","instructor":"Mammoth Interactive"}' \
          -H "Content-Type: application/json" \
          -X POST http://localhost:42212/products
//* $ curl -d '{"name":"Abigail Rose","age":80}' \
          -H "Content-Type: application/json" \
          -X POST http://localhost:8080/authors
•PUT req:  This type of HTTP request is for updating an entry entirely in the database
• PUT
   $ curl -d “name=Alex&course=Excel” -X PUT http://localhost:3000/api/people/61326891216b79d8768c6edd
• PUT + JSON data
   $ curl -d '{"instructor":""Mammoth Interactive INC"}' \
          -H "Content-Type: application/json" \
          -X PUT http://localhost:42212/products/2
//* $ curl -d '{"isbn":2,"title":"Python for Automation","author":null}' \
          -H "Content-Type: application/json" \
          -X PUT http://localhost:8080/books/978-1-2345-6789-0
//* in the above example we add the "isbn" in the json req-body to prove that the one
    to be used is the one in the url(sent via params), due to our code definition
•PATCH req:  This type of HTTP request is for updating 1 property of an entry in the database
• PATCH
   $ curl -d name=Mammoth -X PATCH http://localhost:3000/api/people/61326891216b79d8768c6edd
•DELETE req:  This type of HTTP request is for deleting an entry in a database
• DELETE
   $  curl -X DELETE http://localhost:3000/api/people/61325f4594bd88dec1e165cb

► WEB Layer Testing (for HTTP requests), with Spring Boot MockMVC
• to make Controller Integration Tests
• MockMvc
  ♦ Is part of Spring Test, MockMvc simulates HTTP requests to Spring MVC controllers
  ♦ Main entry point for server-side Spring MVC test support.
  ♦ from org.springframework.test.web.servlet.MockMvc;
  ♦ MockMvc allows us to test the web layer without starting the full HTTP server, start an in-memory one
• @AutoConfigureMockMvc
  ♦ Used by SpringBoot to -inject- a "MockMvc instance" that we can use to simulate HTTP requests and verify responses
• private MockMvc mockMvn;
  ♦ MockMVC instance that needs to be inject to be able to use:
    ◘ .perform() ,  to make http requests, with:  MockMvcRequestBuilders class methods(chained)
      ◙ like:  .post( "url / urlTemplate" )
               .contentType( MediaType.APPLICATION_JSON )
               .content( objectJsonString )
    ◙ and chain to it assertions with(as many as needed, one per assertion recommended):
    ◙ .andExpect(
    // with MockMvcResultMatchers class methods like .jsonPath(expression) :
                  .status().isCreated()
                  .jsonPath( "$.id" )  .isNumber()     //.jsonPath( expression-to-find-in-the-json )
                  .jsonPath( "$.name" ).value("Abigail Rose")   //$.name  to check for the name attribute in the json-object
                  .jsonPath( "$.age" ) .value("80")
                );
*• @AutoConfigureMockMvc does NOT auto-create a MockMvc bean in the application context.
  *♦ It only configuresMockMvc to be auto-injected via --@Autowired fields--.
  *♦ It does not make MockMvc available for constructor injection unless you explicitly add it.
  *♦ therefor you can(besides using that annotation with a constructor and another annotation):
    1◘ use @WebMvcTest
      @WebMvcTest(BookController.class)
      ...
      private final MockMvc mockMvc;      // field injection, auto-done by @WebMvcTest
      private final ObjectMapper objectMapper;
      private final BookService bookService;
    2◘ Use Field Injection (Simpler & Common), with the @AutoConfigureMockMvc annotation
      @Autowired MockMvc mockMvc;
      @Autowired ObjectMapper objectMapper;
      @MockBean BookService bookService;  // or @Autowired if real bean exists
• @WebMvcTest vs @AutoConfigureMockMvc
Feature                     @WebMvcTest                     @AutoConfigureMockMvc
--------                    ------------                    ----------------------
→Loads full                 No (web layer only)             Yes (@SpringBootTest)
 ApplicationContext?
→Auto-creates               Yes                             No
 MockMvc bean?
→Supports field             Yes                             Yes
 injection of MockMvc?
→Supports constructor       Yes (if single constructor)     No
 injection without @Autowired?
→Requires @Autowired        Optional                        Required
 on constructor?
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Use Case                                 Use This
---------                                ---------
→Fast unit test of a single              @WebMvcTest
 controller
→Integration test with full              @SpringBootTest + @AutoConfigureMockMvc
 app context (DB, services, etc.)
→Testing security, filters, or           @SpringBootTest + @AutoConfigureMockMvc
 full request pipeline
→You want to mock only the               @WebMvcTest
 service layer
→You need real beans (e.g.               @SpringBootTest + @AutoConfigureMockMvc
 @Configuration, @Component)
→Controller UNIT Tests                   @WebMvcTest                                ←***
→FULL INTEGRATION Tests                  @SpringBootTest + @AutoConfigureMockMvc    ←***

• ObjectMapper instance injection
  ♦ needed to use Jackson to conver to-and-from Json formatt
  ♦ from com.fasterxml.jackson.databind.ObjectMapper;
    ◘ ObjectMapper provides functionality for reading and writing JSON, either to and from basic
      POJOs (Plain Old Java Objects), or to and from a general-purpose JSON Tree Model (JsonNode),
      as well as related functionality for performing conversions.
    ◘ It also supports more advanced Object concepts...
  ♦ .writeValueAsString( Object );
    ◘ used to convert from POJO to JSON
* throws Exception ,  is needed for MockMvn
  ☼ and already handles JsonProcessingException (needed for objectMapper.writeValueAsString)

* Code to get a list as an Iterable from the DB, and convert it to a List with streams
public List<AuthorEntity> findAll() {
 //authorRepository.findAll(); //it returns an iterable, to make it a list we do:
 return StreamSupport    /*Low-level utility methods for creating and manipulating streams*/
          .stream(       /*Creates a new sequential or parallel Stream from a Spliterator*/
              authorRepository      /*the class that extends the CrudRepository class querying-functionality*/
                    .findAll()      /*returns an iterable; extended CrudRepository-class-method that Returns all instances of the type*/
                    .spliterator(), /*Creates a Spliterator over the elements described by this Iterable*/
              false)     /*to define the stream as true=parallel, false=sequential*/
          .collect(Collectors.toList());  //to collect/convert the resulting stream into a List

* Code to update partial information of an Entity
   return authorRepository.findById(id).map(existingAuthor -> {
      Optional.ofNullable(authorEntity.getAge()).ifPresent(existingAuthor::setAge);
      Optional.ofNullable(authorEntity.getName()).ifPresent(existingAuthor::setName);
      return authorRepository.save(existingAuthor);
    }).orElseThrow(() -> new RuntimeException("Author does not exist"));
/* If the Optional has an Age and is notNull,
    set that as we found it on the existing author as we found it in the DB */
//.ofNullable(), returns an emptyOptional on Null; .of() doesn't

► Pagination
• Needed to save resources to avoid crashed servers, crashed DBs,
  limit views for better UI,
  or just wait times that will affect UX
• So where we can we want to set limits to the numbers of Entites that
  return on those list EndPoints
• Pagination is built-into SpringDataJPA, and spring-web, it goes all the way up the chain
• Interface PagingAndSortingRepository<BookEntity, String> , by implementing it
  ♦ is the one that adds the magic to the Repository, just like CrudRepository interface
• Page & Pageable interfaces, are the way to call a method with pagination
   Page<BookEntity> findAll(Pageable pageable);
  ♦ Page is imported from: org.springframework.data.domain.Page;
  ♦ Pageable is imported from: org.springframework.data.domain.Pageable;
• the "Pageable" object contains metadata about the Page/PaginatedGroupOfEntities
  ♦ we need the pageable to inform what is in the 'Page'
• to use it in your method/endPoint declaration
   @GetMapping("/books")
   public Page<BookDto> listBooks(Pageable pageable) { ... }
* Spring injects the info for us, just by adding the Pageable obj as a meth param
• the returned Json of a paginationMethod
  { "content": [ ...books... ],
    "pageable": { ...pages-metadata... } }
• to control the size of the page
   http://localhost:8080/books?size=2
• to control which page(index) we're currently viewing
   http://localhost:8080/books?size=2$page=1
* which allows us to limit the amount of elements returned by our API
** Pagination here, also allows for 'sorting', and other nice features
• example of the content and metadata:
  {
    "content": [
      { "id": 1, "name": "Alice" },
      { "id": 2, "name": "Bob" }
    ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 2,
      "offset": 0,
      "paged": true
    },
    "totalElements": 25,
    "totalPages": 13,
    "size": 2,
    "number": 0,
    "numberOfElements": 2,
    "first": true,
    "last": false,
    "empty": false
  }




/* === >==>--- Additional Info / Comments / Notes ---<==< === */
/*
► *** Trying to understand this layered architecture
  • Controller  >=>    objDTO    >=>  objEntity  >=>  objService  >=>  objRepository  >=>  toDB
  • Controller  <=<    objDTO    <=<  objEntity  <=<  objService  <=<  objRepository  <=<  toDB
    (View/Reqs)                                   (Make-TheObjRepoCALLS)
                  4Separation       ModelOfTable                   
  ^ PRESENTATION ^             ^ - - SERVICE LAYER - - ^         ^ - - PERSISTENCE LAYER - - ^
    - LAYER -                        +Mappers                             +Entites
  * Interfaces areUsed:  to Encapsulate all the logic for the specific purpose
*/
/*
  Setting a custom BANNER to appear, in console

  • For simple Banner for tests you can just add the resources/banner.txt file
  ***• If you'll use advanced banner createion, remove the/any banner.txt file

  Z• To setup the color
  Red: \u001B[31m
  Green: \u001B[32m
  Yellow: \u001B[33m
  Blue: \u001B[34m
  Reset (to default color)(at end of colored section): \u001B[0m

  A• Banner for Application Context Initialization
    ♦ This banner displays when the Spring application context starts loading (e.g., at app
      startup or test context init). Use a custom implementation of Spring's Banner interface
      for full control over dynamic content.
    ♦ Steps:
      1◙ Create a custom Banner class that generates dynamic content (e.g., current timestamp, Spring Boot version).
        //CustomContextBanner
      2◙ Configure it in application.properties or via a SpringApplication builder (for tests, override in application-test.properties).
      3◙ Placeholders like ${application.title} can be used, but for advanced dynamics, override printBanner.
  B• Banner for Running Tests
    ♦ This banner displays specifically during test execution (e.g., before/after each test
      method or class). Use JUnit's @BeforeEach, @BeforeAll, or a custom TestExecutionListener
      for more control. For dynamic data, access test metadata or runtime info.
    ♦ Steps:
      //CustomTestListener
      1◙ Use @BeforeEach (per test method) or @BeforeAll (per class) to print the banner.
      2◙ For more advanced, implement TestExecutionListener to hook into test lifecycle events.
      3◙ Include dynamic data like test name, method count, or current time.
  C• Banner for Database Loading
    //DatabaseInitBanner
    ♦ This "banner" displays during database initialization (e.g., when the datasource is
      created, schema is applied via JPA/Hibernate, or data is loaded via data.sql).
    ♦ Spring doesn't have a built-in banner for this, but you can hook into events like
      DataSourceInitializedEvent or use a @PostConstruct method in a datasource-dependent bean.
    ♦ Steps:
      1◙ Create a bean that listens for database events or initializes after the datasource.
      2◙ Use ApplicationListener for DataSourceInitializedEvent (fired after datasource setup).
      3◙ Print dynamic data like DB URL, schema version, or row count
    ♦ Different methods / approaches:
| DB Approach     | Event/Class                  | When it runs          | Recommended?         |
| --------------- | ---------------------------- | --------------------- | -------------------- |
| **Old way**     | `DataSourceInitializedEvent` | After datasource init | ❌ Removed            |
| **Modern way**  | `ApplicationReadyEvent`      | After app is ready    | ✅ Recommended        |
| **Alternative** | `SmartInitializingSingleton` | After all beans init  | ✅ Good internal hook |

  • In https://patorjk.com   -you can find the-   /Text to ASCII Art Generator
  or directly:  https://patorjk.com/software/taag/
*/

/*
  Clear
  • Local Maven Repository Cache
    Typically in: 
    ~/.m2/repository
  • My JAVA_HOME dir
  /home/techrules4ever/.sdkman/candidates/java/21.0.6-amzn
  • My M2_HOME dir
  \usr\share\man\man1\mvn.1.gz

  Regarding Tests, Activated profiles, and application-<profile>.properties
  • Profiles: dev, test, prod
  • That name is only visible if profiles are being set and called upon
  • If not, only application.properties will be visible
  • If you are not, or do not want to set/call profiles,
    you need to explicitely activate it in(talikng about test) you test class
    ♦ ie.:  @ActiveProfiles("test") //adding that annotation
  • As per Profiles, you can set them:
    1♦ Via command line
      ○ mvn test -Dspring.profiles.active=test
      or
      ○ export SPRING_PROFILES_ACTIVE=test
    2♦ In application.properties, adding: 
      ○ spring.profiles.active=test
  *• QuickFix for issue with test DB not being reset correclty by annotations:
    ♦ use the setUp method with the @BeforeEach annotation
    ♦ ie.:  @BeforeEach
            void setUp() {
                authorRepository.deleteAll();   //authorRepository needs to have been injected
            }
  
  • Hibernate
    ♦ when using "cascade = CascadeType.ALL" in a @ManyToOne(), it ASSUMES!! like so:
        -- “This Author already exists (it already has an ID), so I should update it, not insert it.” --
          Then it executes something like:  update author set name=?, age=? where id=1
        -- “Wait, nothing was updated — the entity must not exist.” --
          Error! ObjectOptimisticLockingFailureException!
      ◙ A Book entity referencing an Author that has an id=1.
      ◙ “Author with ID 1 must already exist in the database.”
      ◙ It tries to update or attach it.
      ◙ But since that Author was never persisted before, the database has no row with ID 1.
      ◙ → BOOM 💥 ObjectOptimisticLockingFailureException.
*/


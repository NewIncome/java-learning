Spring Rest API development
----------------------------

‚ñ∫ Coding Steps
---------------
1- https://start.spring.io
2- Dependencies add: "Spring Web"
3- 


‚ñ∫ Maven Concepts
-----------------
‚Ä¢ Apache Maven
  ‚óã Helper to manage projects and all needed to build, test, package-it
  ‚óã MVN has 3 main phases or Life-cycles, with certain goals in each
    ‚ô¶ each name is also the mvn command to be used
    ‚ô¶ clean   - remove temp dirs and files
      ‚óô pre-clean   - hooks for before cleaning
      ‚óô clean       - the actual cleaning
      ‚óô post.clean  - hooks for after cleaning
    ‚ô¶ 2. default - where most useful goals live
      //* if called 'default' it will run the goals in order
      ‚óô compile   - compiles code into bytecode
      ‚óô test      - runs unit tests
      ‚óô package   - creates a jar or war file
      ‚óô verify    - runs checks and integration tests
      //* if you run a specific goal-command, it'll run the previous goals
    ‚ô¶ 3. site    - where documentation is generated

  ‚óã 'target' directory
    ‚ô¶ is where all th eproject is actually being built
    ‚ô¶ which is what gets cleaned out in the 'clean phase'
  ‚óã 'src/main/resources/application.properties
    ‚ô¶ this is where we would configure our app
     ie.: with other file to load etc.
    ‚ô¶ the Tests dir also has a the same dir/file for config

  ‚óã Commands while developing
  // $ mvn clean test  //is a good way to make sure everything is ok before testing
  // $ java -jar restapi-0.0.1-SNAPSHOT.jar  //to run the compiled file as we would in production. And can bee seen as if run normally; port 8080
      this being inside the target/ directory
  // $ mvn spring-boot:run
    ‚ô¶ clean > compile > run/test
  // $ mvn package
  // $ java -jar <name of created project .jar file>
      to run project from the final packaged .jar file, this with envVars


‚ñ∫ Spring Framework
--------------
By itself is highly configurable, but a lof of work
‚Ä¢ LAYERS
  ‚ô¶ Presentation ,  use all the data from the 'Service layer' and expose it to the user
    ‚óô with a RestAPI which uses controllers for implementation
      or a GraphQL-API, or WebSockets-API
  ‚ô¶ Service ,  use all of the functionality exposed by the 'persistence layer'
      and use it to meet the requirements our application is built to handle
    ‚óô with Services
  ‚ô¶ Presistence ,  handles interactions with our DB
    ‚óô with Entities
    ‚óô with Repository patterns, and DAO's patterns (DataAccessObject) - CRUD


‚ñ∫ Spring Boot
--------------
Is a layer built on top of -Spring Framework-
‚Ä¢ Puspose is to provide additional functionality
‚Ä¢ Helps managing and creating Beans and Interfaces, by sensible defaults

‚ñ≤ IOC, DependencyInjection
‚Ä¢ What the Framework does? Provides and injects the classes/dependencies/Beans
‚Ä¢ We just need to make the Interfaces for our main class
‚Ä¢ Ways of configuring Beans:
  ‚ô¶ by the @Configuration class
  ‚ô¶ by the @Component annotation (& friends)

‚ñ≤ Component Scanning
Is a process that starts when your application starts up
‚Ä¢ Spring Boot will look through your project
  ‚ô¶ It's going to look for Beans and where Beans are needed (in the constructor of a Bean)
‚Ä¢ Then it adds them as Beans to the Spring App Context
‚Ä¢ If it has dependencies it'll look for them in the context, and add them where they're needed
  ‚ô¶ That process is called 'Dependency Injection', and also 'Autowiring'(more Spring specific term)
‚Ä¢ Traditionally an @ComponentScan annotation declared the start of the startpoint of the Beans to scan and forward down the tree
  ‚ô¶ but now it's done by @SpringBootAplication annotation

‚ñ≤ The @SpringBootAplication annotation
Is an alias for many other different annotations
‚Ä¢ the main 3:
  1. @Configuration ,  identifies a configuration class
    ‚óô which is a place to look for Beans during the ComponentScanning phase
  2. @ComponentScan ,  sets the hierarchy point
    ‚óô to, from that point down, look for Beans and places that Beans are needed
  3. @EnableAutoConfiguration ,  provides all the sensible-defaults that make SprintBoot great
    ‚óô also adds create all needed and set Dependencies

‚ñ≤  @EnableAutoConfiguration
‚Ä¢ the SpringBootStarters are a collection of the Dependencies above mentioned
  ‚ô¶ one is for example 'SpringWeb' == spring-boot-starter-web
    ‚óô which is a collection of dependencies needed to implement a web project
    ‚óô like: SpringMVC and embeddedTomCat

‚Ä¢ pom.xml file ,  is where all out dependencies can be found

//* Specially used annotations:
   ‚óã @ConditionalOnClass({ClassName.class}) ,  when the {class} is available on the class path,
     the following class should be instantiated and run
   ‚óã @ConditionalOnBean(Bean) ,  when this bean is available the following part of the config/code should be run
   ‚óã @ConditionalOnMissingBean(Bean) ,  run the following code when the Bean is missing


‚ñ≤  Configuration Files to Set "Sensible Defaults"
1‚Ä¢ We have the src/main/resources/application.properties file
  ‚ô¶ where we can set some special properties like: server.port=8181
  ‚ô¶ We can find docs for all in: https://docs.spring.io/spring-boot/appendix/application-properties/index.html
  ‚ô¶ Also, if we desire another code format, we can rename the file to:
    application.yml
    ‚óô with that name our format would be:
      server:
        port: 8181
‚Ä¢ We can also have this file for Tests, in test/resources/application.properties
2‚Ä¢ Do this with Environment Variables:
  ‚ô¶ SERVER_PORT=8181
  ‚ô¶ This can be done at time of running maven
    $ SERVER_PORT=8080 mvn spring-boot:run
  ‚ô¶ Or set in temporary env variables in that terminal session
    $ export SERVER_PORT=8080
    Then run the application normally, it will pick up the env variables automatically
3‚Ä¢ We can also use @ConfigurationProperties annotation
  ‚ô¶ which also needs the @Configuration annotation put first
    ‚óô to tell Spring to look at that class to look for Beans, for config
  ‚ô¶ Then in your application.properties you can have the variables to be picked up like:
    pizza.sauce=bbq
    //and in the code:
    @Configuration
    @ConfigurationProperties(prefix="pizza")
    public class PizzaConfig { private String sauce }
    //that code to be then injected(say via ConstructorInjection) to the main class for use


‚ñ∫ DataBase and DataBase Layers
‚Ä¢ Database Driver - allows to interact with the DB from your java code
‚Ä¢ JDBC (JavaDataBaseConnectivity) - LowLevel API, for sql queries
‚Ä¢ Spring JDBC - adds spring magic to normal JDBC with 'templates'
‚Ä¢ JPA (JavaPersistenceApi) - Allows interaction with DB by JavaObjects
  ‚ô¶ is also built on top of JDBC, so considered a HighLevel API
  ‚ô¶ technically JPA is a specification
  ‚ô¶ the implementation in Spring is done by 'Hibernate'
‚Ä¢ Spring Data JPA - adds spring magic, such as defined repositories
‚Ä¢ Hibernate is an ORM

‚ñ≤  H2 in-memory DB
‚Ä¢ You just connect to it by
  ‚ô¶ injecting a DataSource dataSource dep
  ‚ô¶ creating a new JdbcTemplate(dataSource)
  ‚ô¶ and using the JdbcTemplate like:  restTemplate.execute("select 1");
‚Ä¢ You can configure it if desired in the application.properties file with:
  ‚ô¶ spring.application.name=database01
    spring.datasource.url=jdbc:h2:mem:testdb
    spring.datasource.driverClassName=org.h2.Driver
    spring.datasource.username=sa
    spring.datasource.password=password
‚Ä¢ for Testing, also has some specific settings to allow it to emulate quircks of some databases(like postgres)
  ‚ô¶ ie.:  spring.datasource.url=jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    ‚óô jdbc:h2:mem:testdb
    ‚óô MODE=PostgreSQL ,  to emulate postgres
    ‚óô DATABASE_TO_LOWER=TRUE ,  to set everything to lower-case to replicate postgres behaviour
‚ñ≤  with PostgreSQL and other DB's
‚Ä¢ the Java code will be exactly the same
‚Ä¢ the difference will be in the configuration, in application.properties
‚Ä¢ then you just need to run/start the DB and it should work
  ‚ô¶ you can do so with docker

‚Ä¢ View on DBeaver, graphical view of DB's
  ‚ô¶ keep open the DB connection (easier with Docker-compose)
  ‚ô¶ open in same port
  ‚ô¶ add password
  ‚ô¶ test connection
  ‚ô¶ finish
‚Ä¢ you can view it in the path:  postgres > Databases > postgres > Schemas > public > Tables > "tableName"
  ‚ô¶ double click there, then selec tab 'Data' to view the info in the table
  ‚ô¶ or 'ER Diagram' to view the column names

* 1:17:00 ,  Interesting short code, pizza proj
  + uses well structured String.format
  + uses @Log, and @Data annotations (also @AllArgsConstructor, @NoArgsConstructor)
  + uses "lombok"(Logger), ... , has great annotations that automate code ...

‚ñ≤ JdbcTemplate and DAO pattern(Data Access Object)
‚Ä¢ DAO ,  objects that reference and map to tables in a DB
‚Ä¢ Those Dao's start being interfaces
‚Ä¢ Those interfaces need implementations
  ‚ô¶ those will 'always' need the JdbcTemplate
‚Ä¢ @Configuration ,  Declares that a class is a source of Bean definitions
  ‚ô¶  It tells the Spring container that this class contains one or more @Bean methods that Spring should process and manage
  ‚ô¶* Sets like the 'Database Setup Blueprint'
‚Ä¢ @Bean , Marks a method whose return value should be registered as a Bean in the Spring application context
‚Ä¢ @Builder , It's purpose is to automatically implement the Builder Design Pattern for your class
*** The Builder pattern
  + is a creational design pattern that allows you to construct complex objects step-by-step using a fluent, readable API
  + generates all the necessary code for this pattern, including:
    > A static inner class (the actual "Builder")
    > A static builder() method on the main class that returns an instance of the inner builder
    > Methods on the builder class for each field
    > A build() method that creates and returns the final object
  + Solves the "Telescoping Constructor" Problem:
    > When a class has many optional fields, you would traditionally need
      to write a long, tedious constructor with all possible parameters
      (or many overloaded constructors). The builder pattern, and thus
      @Builder, solves this by allowing you to set only the fields you need,
      in any order.
  +* Facilitates Immutable Objects
    > Commonly used to construct objects where all fields are final
    > Since all values are passed to the builder before the object is created (when build() is called),
      it's the ideal tool for creating fully immutable objects
‚Ä¢‚Ä¢ SetUp
 ‚ô¶ The "Configuration Class way"
  ‚óô creating a configuration class to define all our beans that'll there be registered to the Spring Application Context
  ‚óô ie.:  config/DatabaseConfig.java  //(class) with many Contructor injected Beans
‚Ä¢ Base files:
  1‚ô¶ Domain ,  class files for our Models / objects - to replicate DB tables
  2‚ô¶ DAO's ,  interfaces that will be blueprint for the actions/methods performable to those
  objects(the domain)
  3‚ô¶ Implementations(impl's) ,  classes that will implement the DAO's interface methods
‚Ä¢ Test configuration
  ‚ô¶ add the H2 DB with the scope of 'test', in the pom file
  ‚ô¶ set-it-up in the test/resources/application.properties file

‚ñ≤ Test Driven Development (TDD)
‚Ä¢> Steps to a Create UNIT test:
  1‚ô¶ Create the dao/AuthorDaoImplTests file
  2‚ô¶ then test testThatCreatesAuthorAndGeneratesCorrectSql()
    ‚óô create an Author with Author.builder().build();  ie.: ...builder().id().name()...build();
  3‚ô¶ then declare the AuthorDao interface create() method
  4‚ô¶ then create the AuthorDaoImpl create() method, empty
  5‚ô¶ then assert the test with argument matchers
  6‚ô¶ then run the test, it should fail
  7‚ô¶ then populate the AuthorDaoImpl create() method
  8‚ô¶ then run the test, it should pass Ok
('till 2:02:00)
‚Ä¢ @ExtendWith(*.class) ,  is a repeatable annotation that is used to register extensions for the annotated
    test class, test interface, test method, parameter, or field
  ‚ô¶ Annotated parameters are supported in test class constructors, in test methods, and in
    @BeforeAll, @AfterAll, @BeforeEach, and @AfterEach lifecycle methods.
  ‚ô¶ @ExtendWith fields may be either static or non-static
  ‚ô¶ (*.class) ,  are sort of help classes that will be registered as extensions
    ‚óô It have many with repeated @ExtendWith annotations
  ‚ô¶ @ExtendWith(MockitoExtension.class)
    ‚óô This annotation integrates Mockito with JUnit 5
    ‚óô It enables Mockito to initialize mocks and inject them into the test class
‚Ä¢ @Mock ,  this Mockito annotation creates a mock(fake) object of 'the JdbcTemplate class for example'
  ‚ô¶ A mock is a fake object that simulates the behavior of the real JdbcTemplate
‚Ä¢ @InjectMocks ,  this annotation tells Mockito to create an instance of 'AuthorDaoImpl for example'
  ‚ô¶ and automatically inject the mocked jdbcTemplate into it
  ‚ô¶* Typically, 'AuthorDaoImpl for example' has a dependency on JdbcTemplate(the class annotated with Mock)
  ‚ô¶ and Mockito handles this dependency injection for the test
‚Ä¢ @Test ,  is used to signal that the annotated method is a test method
  ‚ô¶ This JUnit 5 annotation marks the method as a test case
  ‚ô¶ body structure:
    public void testThatCreateBookGeneratesCorrectSql() { //descriptive method name
        Author author = Author.builder().id(1L).name("Abigail Rose").age(80).build(); //build the obj
        underTest.create(author);   //create(db access to set) the obj

        verify(jdbcTemplate).update(
        eq("INSERT INTO authors (id, anme, age) VALUES (?, ?, ?)"),
        eq(1L), eq("Abigail Rose"), eq(80));
  ‚ô¶ verify(jdbcTemplate): This Mockito method checks whether a specific interaction occurred
    with the mocked jdbcTemplate
    ‚óô Verifies certain behavior happened once
    ‚óô verify(mock, times(1)).someMethod("some arg");
      ‚óò the 'times()' parameter is optional, and default to 1
  ‚ô¶ .update(...): It verifies that the update method of jdbcTemplate was called exactly once
    with the specified arguments
  ‚ô¶ eq(field_data): Argument matcher used to match with specific field data
‚Ä¢ The Builder pattern
  ‚ô¶ is like a helper that lets you build an object step-by-step
  ‚ô¶ It is a design pattern that makes it easier to create complex objects
with many fields or optional parameters in a clean, readable, and flexible way.
  ‚ô¶ It‚Äôs especially useful when you want to avoid messy constructors with lots of arguments or
    when some fields are optional.
  ‚ô¶ .builder() ,  inner class to set the fields one at a time
  ‚ô¶ .build() ,  method to create the final object
  ‚ô¶ Avoids Constructor Overload
    ‚óô if you might need multiple constructors for different combinations, the Builder pattern uses
    one clear way to set any combination of fields
‚Ä¢ org.mockito.ArgumentMatchers
  ‚ô¶ Allow flexible verification or stubbing
‚Ä¢> Steps to create INTEGRATION tests
  ‚ô¶ in this case to run the sql agains an in-memory DB
‚Ä¢ @SpringBootTest ,  to startup a test version of our application when our test runs
  ‚ô¶ This Spring Boot annotation is used for integration tests.
  ‚ô¶ It sets up a full Spring application context, loads beans, and enables Spring-specific
    features like dependency injection and transaction management.
  ‚ô¶ Importantly, @SpringBootTest already includes @ExtendWith(SpringExtension.class) as part
    of its implementation (via its meta-annotations)
  ‚ô¶** Here a Constructor for ConstructorInjection is necessary
    ‚óô AND it's necessary that it uses the @Autowired annotation
    ‚óô* It's necessary to write the ConstructorInjection method and use the @Autowired annotation because:
      ‚óò in Tests beans are not managed like the Spring Application, that's why you can't use @*ArgsConstructor
      ‚óò And @Autowired is convention in integration tests
‚Ä¢* @Transactional ,  it wraps the test in a database transaction and rolls back all database changes(by default)
      (e.g., inserting authors or books) after each test, ensuring a clean database state for subsequent tests
  ‚ô¶ the default behaviour is configurable with @Transactional(rollback = false)
  ‚ô¶ Can specify transaction propagation, isolation levels, and timeouts (e.g., @Transactional(propagation = Propagation.REQUIRES_NEW))
  ‚ô¶ Purpose: Manages database transactions and rollbacks
  ‚ô¶ Scope: Database operations within a test
  ‚ô¶ Performance Impact: Minimal, as it only manages transactions
‚Ä¢ @DirtiesContext ,    Marks a test as "dirtying" the Spring application context, forcing Spring to recreate the context for subsequent tests
  ‚ô¶ Ensures that context modifications don‚Äôt affect other tests, preventing test interference
  ‚ô¶ from org.springframework.test.annotation.DirtiesContext
  ‚ô¶ Spring caches the application context between tests for performance
    If a test modifies the context (e.g., by changing bean definitions, configurations, or
    in-memory database state), @DirtiesContext tells Spring to discard the current context and
    create a fresh one for the next test
  ‚ô¶ Supports different scopes for context invalidation
    (e.g., @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD) orClassMode.AFTER_CLASS)
  ‚ô¶ Purpose: Use @DirtiesContext when a test alters the Spring application context (e.g., bean definitions,
    properties, or shared resources) and you need to ensure a fresh context for other tests to avoid side effects
  ‚ô¶ Scope: Spring application context state
  ‚ô¶ Performance Impact: Higher, as recreating the context is resource-intensive
    ‚óô thus, avoid overusing, use it only when necessary (e.g., when shared resources or beans are modified)
  //‚ô¶* In some cases, you might use both annotations in a test
‚ñ≤ Assertions
‚Ä¢ assertThat(queryResult) ,  used to assess a result of a query operation(like find*)
  ‚ô¶ therefor it is used upon a Collection of elements like: List<>, Optional<>, Iterable<>
  ‚ô¶ it has many sub-implementations like:
    ‚óô matches(b), isEqualTo(b), isNull(), isNotNull(), isEmpty(), isPresent(),
      .hasSize(i), contains(obj,...), and many more..
  ‚ô¶ these assertions can be sequential, or added one after another in one assertThat()
‚Ä¢ ‚Ä¢* CustomQuery's WITHOUT implementation!!!
  ‚ô¶ Spring JPA is able to workout(auto-implement) custom queries based on just:
    -how you name your methods-
    -and the correlation of the methodParam vs the instanceVariables in the Object at hand
      ‚óô ie.:  Iterable<Author> ageLessThan(int age);  //declaration, no manual implementation
                //propertyLessThan(T Object.property)
              Iterable<Author> result = underTest.ageLessThan(50);  //usage

‚ñ≤ CRUD (Create Read Update Delete)
‚Ä¢ C - create
‚Ä¢ R - read. There are typically 2 ways of doing it:
  ‚ô¶ read one obj ,  and look for it by 'id'
    ‚óô if no object is found return null typically or empty
  ‚ô¶ read many ,  and either show a large list
                      show a filtered sub-set of the list
    ‚óô if no objects show in the list show an empty list

‚Ä¢ Optional<ObjectClass>
  ‚ô¶ used to get an Optional obj back from a query if nothing is found, instead of getting null
  ‚ô¶ A container object which may or may not contain a non-null value
  ‚ô¶ If a value is present, isPresent() returns true
  ‚ô¶ If no value is present, the object is considered empty and isPresent() returns false
  ‚ô¶ when crud method auto-generated from interface to implementationClass it comes with:
      return Optional.empty();

‚ñ≤ RowMapper
‚Ä¢ Used to convert from a ResultSet and convert it into an object
  ‚ô¶* Also used to query a DB with a defined object structure
‚Ä¢ ResultSet ,  is whats returned when querying a database
‚Ä¢ Because we are using Jdbc and DAO pattern,
  we need to handle the conversion to-and-from SQL and Java objects our selfs
  For this we can use RowMappers, ResultSetExtractors, RowBackHandlers
‚Ä¢ Querying a DB with JdbcTemplate and RowMapper, to get a list of objects
  ‚ô¶ List<Author> list = jdbcTemplate.query(String sql, RowMapper<Author> rowMapper, @Nullable Object... args)

(now at 2:34:00)
(now at 3:05:00)

‚ñ∫ JPA and Hibernate
JPA is a Higher-level API, and takes care of a lot of the lower level details for you
‚Ä¢ eg.: we don't need to touch SQL queries with this module

// //feat: Steps to transform from using Jdbc to Spring JPA Data implementation
Changes regarding files and directories
1. Remove schema.sql file. Hibernate will take care of that for us
2. Remove all the DAO's(Author&Book Dao's and Implementations, the whole dir). All the SQL will be generated by JPA
3. Remove the config/DatabaseConfig file. It inyected the JdbcTempalte as the DataSource
4. Remove UnitTest files. And create repositories dir
5. Move the Integration tests to the repositories dir/package
6. Remove the test/Dao dir
7. Comment out all the Integration tests meanwhile
8. Add the JPA dependency in the pom, and remove the Jdbc dependency
Changes regarding new dirs, files
9. Create the package repositories/
  ‚óã with the interfaces AuthorRepository and BookRepository
  //typically Repositories are not tested because the Dependency does the implementations already
*10. Update our Data/Domain AccessObjects(DAO's) or POJOS(PlainOldJavaObject) to become ENTITIES
‚Ä¢ to convert the POJOS into Entities:
  ‚ô¶ @Entity ,  label object as an Entity that can be used with Soring Data Jpa
  ‚ô¶ @Table(name = "authors") ,  to define which table it maps to in the DB
  ‚ô¶ @Id ,  to define the field as the PrimaryKey of the entity/table
  ‚ô¶ @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "author_id_seq")
    ‚óô Used to auto-generate id's(numeric values starting from 1)
    ‚óô*  This tells JPA:
        - ‚ÄúUse a database sequence named author_id_seq to generate IDs for new Authors.‚Äù -
        //If you manually set .id(1L) in your test data, Hibernate sees that and thinks:
          - ‚ÄúThis Author already exists (it already has an ID), so I should update it, not insert it.‚Äù -
‚Ä¢ @ManyToOne(cascade = CascadeType.ALL) ,  to specify the relationship with the ForeignKey
  ‚ô¶ and to be able to get the authorObj when we call the bookObj

‚ñ≤ Hibernate Auto DDL
Help to setup the schema for you
‚Ä¢ DDL stands for Data Definition Language
  ‚ô¶ DDL commands are used in SQL to manage the structure and schema of the database
  ‚ô¶ The most common DDL operations are:
    ‚óô CREATE (tables, indexes, etc.)
    ‚óô DROP (delete tables, indexes, etc.)
    ‚óô ALTER (modify table structure)
‚Ä¢ in resources/application.properties add
  ‚ô¶ spring.jpa.hibernate.ddl-auto=update
    #so our schema is updated when we change our Entities
‚Ä¢ To try it you can start your DB in docker, run DBEAVER, check the tables
  ‚ô¶ and also you can check the 'sequences' setup in the same dir as your tables
  ‚ô¶ sequences setup using the @GeneratedValue annotation

Create end-point and ReadOne
‚Ä¢ With JPA ENTITES you don't need to make the implementations(for CRUD func)
  ‚ô¶ it's done by extending your entity interface with CrudRepository<ObjType, IDtype>
  ‚ô¶ ... extends CrudRepository<Author, Long> {..}
‚Ä¢ JPA's CrudRepository<T ID> interface adds many method implementations like:
  //‚ô¶ can be seen in the org.springframework.data.repository.CrudRepository interface
  ‚ô¶ save, saveAll, existsById, findById, findAll, findAllById, count, deleteById
    delete, deleteAllById, deleteAll
  ‚ô¶ Is an Interface for generic CRUD operations on a repository for a specific type
  ‚ô¶ Methods exposed through this interface allow entities to participate in lifecycle events,
    and optimistic locking if applicable except for some bulk operation methods

@Slf4j
a logger from Lombok
‚Ä¢ to use it:
  ‚ô¶ log.info();



/*
  Setting a custom BANNER to appear, in console

  ‚Ä¢ For simple Banner for tests you can just add the resources/banner.txt file
  ***‚Ä¢ If you'll use advanced banner createion, remove the/any banner.txt file

  Z‚Ä¢ To setup the color
  Red: \u001B[31m
  Green: \u001B[32m
  Yellow: \u001B[33m
  Blue: \u001B[34m
  Reset (to default color)(at end of colored section): \u001B[0m

  A‚Ä¢ Banner for Application Context Initialization
    ‚ô¶ This banner displays when the Spring application context starts loading (e.g., at app
      startup or test context init). Use a custom implementation of Spring's Banner interface
      for full control over dynamic content.
    ‚ô¶ Steps:
      1‚óô Create a custom Banner class that generates dynamic content (e.g., current timestamp, Spring Boot version).
        //CustomContextBanner
      2‚óô Configure it in application.properties or via a SpringApplication builder (for tests, override in application-test.properties).
      3‚óô Placeholders like ${application.title} can be used, but for advanced dynamics, override printBanner.
  B‚Ä¢ Banner for Running Tests
    ‚ô¶ This banner displays specifically during test execution (e.g., before/after each test
      method or class). Use JUnit's @BeforeEach, @BeforeAll, or a custom TestExecutionListener
      for more control. For dynamic data, access test metadata or runtime info.
    ‚ô¶ Steps:
      //CustomTestListener
      1‚óô Use @BeforeEach (per test method) or @BeforeAll (per class) to print the banner.
      2‚óô For more advanced, implement TestExecutionListener to hook into test lifecycle events.
      3‚óô Include dynamic data like test name, method count, or current time.
  C‚Ä¢ Banner for Database Loading
    //DatabaseInitBanner
    ‚ô¶ This "banner" displays during database initialization (e.g., when the datasource is
      created, schema is applied via JPA/Hibernate, or data is loaded via data.sql).
    ‚ô¶ Spring doesn't have a built-in banner for this, but you can hook into events like
      DataSourceInitializedEvent or use a @PostConstruct method in a datasource-dependent bean.
    ‚ô¶ Steps:
      1‚óô Create a bean that listens for database events or initializes after the datasource.
      2‚óô Use ApplicationListener for DataSourceInitializedEvent (fired after datasource setup).
      3‚óô Print dynamic data like DB URL, schema version, or row count
    ‚ô¶ Different methods / approaches:
| DB Approach     | Event/Class                  | When it runs          | Recommended?         |
| --------------- | ---------------------------- | --------------------- | -------------------- |
| **Old way**     | `DataSourceInitializedEvent` | After datasource init | ‚ùå Removed            |
| **Modern way**  | `ApplicationReadyEvent`      | After app is ready    | ‚úÖ Recommended        |
| **Alternative** | `SmartInitializingSingleton` | After all beans init  | ‚úÖ Good internal hook |

  ‚Ä¢ In https://patorjk.com   -you can find the-   /Text to ASCII Art Generator
  or directly:  https://patorjk.com/software/taag/
*/
/*
  Clear
  ‚Ä¢ Local Maven Repository Cache
    Typically in: 
    ~/.m2/repository
  ‚Ä¢ My JAVA_HOME dir
  /home/techrules4ever/.sdkman/candidates/java/21.0.6-amzn
  ‚Ä¢ My M2_HOME dir
  \usr\share\man\man1\mvn.1.gz

  Regarding Tests, Activated profiles, and application-<profile>.properties
  ‚Ä¢ Profiles: dev, test, prod
  ‚Ä¢ That name is only visible if profiles are being set and called upon
  ‚Ä¢ If not, only application.properties will be visible
  ‚Ä¢ If you are not, or do not want to set/call profiles,
    you need to explicitely activate it in(talikng about test) you test class
    ‚ô¶ ie.:  @ActiveProfiles("test") //adding that annotation
  ‚Ä¢ As per Profiles, you can set them:
    1‚ô¶ Via command line
      ‚óã mvn test -Dspring.profiles.active=test
      or
      ‚óã export SPRING_PROFILES_ACTIVE=test
    2‚ô¶ In application.properties, adding: 
      ‚óã spring.profiles.active=test
  *‚Ä¢ QuickFix for issue with test DB not being reset correclty by annotations:
    ‚ô¶ use the setUp method with the @BeforeEach annotation
    ‚ô¶ ie.:  @BeforeEach
            void setUp() {
                authorRepository.deleteAll();   //authorRepository needs to have been injected
            }
  
  ‚Ä¢ Hibernate
    ‚ô¶ when using "cascade = CascadeType.ALL" in a @ManyToOne(), it ASSUMES!! like so:
        -- ‚ÄúThis Author already exists (it already has an ID), so I should update it, not insert it.‚Äù --
          Then it executes something like:  update author set name=?, age=? where id=1
        -- ‚ÄúWait, nothing was updated ‚Äî the entity must not exist.‚Äù --
          Error! ObjectOptimisticLockingFailureException!
      ‚óô A Book entity referencing an Author that has an id=1.
      ‚óô ‚ÄúAuthor with ID 1 must already exist in the database.‚Äù
      ‚óô It tries to update or attach it.
      ‚óô But since that Author was never persisted before, the database has no row with ID 1.
      ‚óô ‚Üí BOOM üí• ObjectOptimisticLockingFailureException.
*/


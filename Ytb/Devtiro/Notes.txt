Spring Rest API development
----------------------------

► Coding Steps
---------------
1- https://start.spring.io
2- Dependencies add: "Spring Web"
3- 


► Maven Concepts
-----------------
• Apache Maven
  ○ Helper to manage projects and all needed to build, test, package-it
  ○ MVN has 3 main phases or Life-cycles, with certain goals in each
    ♦ each name is also the mvn command to be used
    ♦ clean   - remove temp dirs and files
      ◙ pre-clean   - hooks for before cleaning
      ◙ clean       - the actual cleaning
      ◙ post.clean  - hooks for after cleaning
    ♦ 2. default - where most useful goals live
      //* if called 'default' it will run the goals in order
      ◙ compile   - compiles code into bytecode
      ◙ test      - runs unit tests
      ◙ package   - creates a jar or war file
      ◙ verify    - runs checks and integration tests
      //* if you run a specific goal-command, it'll run the previous goals
    ♦ 3. site    - where documentation is generated

  ○ 'target' directory
    ♦ is where all th eproject is actually being built
    ♦ which is what gets cleaned out in the 'clean phase'
  ○ 'src/main/resources/application.properties
    ♦ this is where we would configure our app
     ie.: with other file to load etc.
    ♦ the Tests dir also has a the same dir/file for config

  ○ Commands while developing
  // $ mvn clean test  //is a good way to make sure everything is ok before testing
  // $ java -jar restapi-0.0.1-SNAPSHOT.jar  //to run the compiled file as we would in production. And can bee seen as if run normally; port 8080
      this being inside the target/ directory
  // $ mvn spring-boot:run
    ♦ clean > compile > run/test
  // $ mvn package
  // $ java -jar <name of created project .jar file>
      to run project from the final packaged .jar file, this with envVars


► Spring Framework
--------------
By itself is highly configurable, but a lof of work
• LAYERS
  ♦ Presentation ,  use all the data from the 'Service layer' and expose it to the user
    ◙ with a RestAPI which uses controllers for implementation
      or a GraphQL-API, or WebSockets-API
  ♦ Service ,  use all of the functionality exposed by the 'persistence layer'
      and use it to meet the requirements our application is built to handle
    ◙ with Services
  ♦ Presistence ,  handles interactions with our DB
    ◙ with Entities
    ◙ with Repository patterns, and DAO's patterns (DataAccessObject) - CRUD


► Spring Boot
--------------
Is a layer built on top of -Spring Framework-
• Puspose is to provide additional functionality
• Helps managing and creating Beans and Interfaces, by sensible defaults

▲ IOC, DependencyInjection
• What the Framework does? Provides and injects the classes/dependencies/Beans
• We just need to make the Interfaces for our main class
• Ways of configuring Beans:
  ♦ by the @Configuration class
  ♦ by the @Component annotation (& friends)

▲ Component Scanning
Is a process that starts when your application starts up
• Spring Boot will look through your project
  ♦ It's going to look for Beans and where Beans are needed (in the constructor of a Bean)
• Then it adds them as Beans to the Spring App Context
• If it has dependencies it'll look for them in the context, and add them where they're needed
  ♦ That process is called 'Dependency Injection', and also 'Autowiring'(more Spring specific term)
• Traditionally an @ComponentScan annotation declared the start of the startpoint of the Beans to scan and forward down the tree
  ♦ but now it's done by @SpringBootAplication annotation

▲ The @SpringBootAplication annotation
Is an alias for many other different annotations
• the main 3:
  1. @Configuration ,  identifies a configuration class
    ◙ which is a place to look for Beans during the ComponentScanning phase
  2. @ComponentScan ,  sets the hierarchy point
    ◙ to, from that point down, look for Beans and places that Beans are needed
  3. @EnableAutoConfiguration ,  provides all the sensible-defaults that make SprintBoot great
    ◙ also adds create all needed and set Dependencies

▲  @EnableAutoConfiguration
• the SpringBootStarters are a collection of the Dependencies above mentioned
  ♦ one is for example 'SpringWeb' == spring-boot-starter-web
    ◙ which is a collection of dependencies needed to implement a web project
    ◙ like: SpringMVC and embeddedTomCat

• pom.xml file ,  is where all out dependencies can be found

//* Specially used annotations:
   ○ @ConditionalOnClass({ClassName.class}) ,  when the {class} is available on the class path,
     the following class should be instantiated and run
   ○ @ConditionalOnBean(Bean) ,  when this bean is available the following part of the config/code should be run
   ○ @ConditionalOnMissingBean(Bean) ,  run the following code when the Bean is missing


▲  Configuration Files to Set "Sensible Defaults"
1• We have the src/main/resources/application.properties file
  ♦ where we can set some special properties like: server.port=8181
  ♦ We can find docs for all in: https://docs.spring.io/spring-boot/appendix/application-properties/index.html
  ♦ Also, if we desire another code format, we can rename the file to:
    application.yml
    ◙ with that name our format would be:
      server:
        port: 8181
• We can also have this file for Tests, in test/resources/application.properties
2• Do this with Environment Variables:
  ♦ SERVER_PORT=8181
  ♦ This can be done at time of running maven
    $ SERVER_PORT=8080 mvn spring-boot:run
  ♦ Or set in temporary env variables in that terminal session
    $ export SERVER_PORT=8080
    Then run the application normally, it will pick up the env variables automatically
3• We can also use @ConfigurationProperties annotation
  ♦ which also needs the @Configuration annotation put first
    ◙ to tell Spring to look at that class to look for Beans, for config
  ♦ Then in your application.properties you can have the variables to be picked up like:
    pizza.sauce=bbq
    //and in the code:
    @Configuration
    @ConfigurationProperties(prefix="pizza")
    public class PizzaConfig { private String sauce }
    //that code to be then injected(say via ConstructorInjection) to the main class for use


► DataBase and DataBase Layers
• Database Driver - allows to interact with the DB from your java code
• JDBC (JavaDataBaseConnectivity) - LowLevel API, for sql queries
• Spring JDBC - adds spring magic to normal JDBC with 'templates'
• JPA (JavaPersistenceApi) - Allows interaction with DB by JavaObjects
  ♦ is also built on top of JDBC, so considered a HighLevel API
  ♦ technically JPA is a specification
  ♦ the implementation in Spring is done by 'Hibernate'
• Spring Data JPA - adds spring magic, such as defined repositories
• Hibernate is an ORM

▲  H2 in-memory DB
• You just connect to it by
  ♦ injecting a DataSource dataSource dep
  ♦ creating a new JdbcTemplate(dataSource)
  ♦ and using the JdbcTemplate like:  restTemplate.execute("select 1");
• You can configure it if desired in the application.properties file with:
  ♦ spring.application.name=database01
    spring.datasource.url=jdbc:h2:mem:testdb
    spring.datasource.driverClassName=org.h2.Driver
    spring.datasource.username=sa
    spring.datasource.password=password
• for Testing, also has some specific settings to allow it to emulate quircks of some databases(like postgres)
  ♦ ie.:  spring.datasource.url=jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    ◙ jdbc:h2:mem:testdb
    ◙ MODE=PostgreSQL ,  to emulate postgres
    ◙ DATABASE_TO_LOWER=TRUE ,  to set everything to lower-case to replicate postgres behaviour
▲  with PostgreSQL and other DB's
• the Java code will be exactly the same
• the difference will be in the configuration, in application.properties
• then you just need to run/start the DB and it should work
  ♦ you can do so with docker

• View on DBeaver, graphical view of DB's
  ♦ keep open the DB connection (easier with Docker-compose)
  ♦ open in same port
  ♦ add password
  ♦ test connection
  ♦ finish
• you can view it in the path:  postgres > Databases > postgres > Schemas > public > Tables > "tableName"
  ♦ double click there, then selec tab 'Data' to view the info in the table
  ♦ or 'ER Diagram' to view the column names

* 1:17:00 ,  Interesting short code, pizza proj
  + uses well structured String.format
  + uses @Log, and @Data annotations (also @AllArgsConstructor, @NoArgsConstructor)
  + uses "lombok"(Logger), ... , has great annotations that automate code ...

▲ JdbcTemplate and DAO pattern(Data Access Object)
• DAO ,  objects that reference and map to tables in a DB
• Those Dao's start being interfaces
• Those interfaces need implementations
  ♦ those will 'always' need the JdbcTemplate
• @Configuration ,  Declares that a class is a source of Bean definitions
  ♦  It tells the Spring container that this class contains one or more @Bean methods that Spring should process and manage
  ♦* Sets like the 'Database Setup Blueprint'
• @Bean , Marks a method whose return value should be registered as a Bean in the Spring application context
• @Builder , It's purpose is to automatically implement the Builder Design Pattern for your class
*** The Builder pattern
  + is a creational design pattern that allows you to construct complex objects step-by-step using a fluent, readable API
  + generates all the necessary code for this pattern, including:
    > A static inner class (the actual "Builder")
    > A static builder() method on the main class that returns an instance of the inner builder
    > Methods on the builder class for each field
    > A build() method that creates and returns the final object
  + Solves the "Telescoping Constructor" Problem:
    > When a class has many optional fields, you would traditionally need
      to write a long, tedious constructor with all possible parameters
      (or many overloaded constructors). The builder pattern, and thus
      @Builder, solves this by allowing you to set only the fields you need,
      in any order.
  +* Facilitates Immutable Objects
    > Commonly used to construct objects where all fields are final
    > Since all values are passed to the builder before the object is created (when build() is called),
      it's the ideal tool for creating fully immutable objects
•• SetUp
 ♦ The "Configuration Class way"
  ◙ creating a configuration class to define all our beans that'll there be registered to the Spring Application Context
  ◙ ie.:  config/DatabaseConfig.java  //(class) with many Contructor injected Beans
• Base files:
  1♦ Domain ,  class files for our Models / objects - to replicate DB tables
  2♦ DAO's ,  interfaces that will be blueprint for the actions/methods performable to those
  objects(the domain)
  3♦ Implementations(impl's) ,  classes that will implement the DAO's interface methods
• Test configuration
  ♦ add the H2 DB with the scope of 'test', in the pom file
  ♦ set-it-up in the test/resources/application.properties file




/*
  Clear
  • Local Maven Repository Cache
    Typically in: 
    ~/.m2/repository
  • My JAVA_HOME dir
  /home/techrules4ever/.sdkman/candidates/java/21.0.6-amzn
  • My M2_HOME dir
  \usr\share\man\man1\mvn.1.gz
*/


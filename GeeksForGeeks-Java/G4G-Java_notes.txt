GeeksforGeeks | Java

--- Introduction to Java ---
• Java is a class-based, object-oriented programming language; run in JVM
• Write Once and Run Anywhere (WORA)
• Java was developed by James Gosling at Sun Microsystems Inc. in May 1995
  ♦ later acquired by Oracle Corporation
• Java is known for its simplicity, robustness, and security features
• By May 8, 2007, the core JVM code was fully available
• Java's core principles: simplicity, robustness, security, high performance, portability, multi-threading, and dynamic interpretation
• Java's Key Features:
JDK > JVM > JRE
  1. Platform Independent
    Compiler converts source code to byte code and then the JVM executes the bytecode generated by the compiler.
  2. Object-Oriented Programming
    ○ The 4 main concepts of Object-Oriented programming are:
	+ Abstraction
	+ Encapsulation
	+ Inheritance
	+ Polymorphism
  3. Simplicity
    Similar to C or C++, and eliminates complex features like pointers and multiple inheritances
  4. Robustness
    Main feats of it's robustness are:
      + Garbage Collection
      + Exception Handling
      + Memory allocation
  5. Security
    Java runs in an environment independent of the OS, and stack corruption or buffer overflow are impossible to exploit in Java. Also it has automatic memory management and type checking
►	☼  STRONG TYPING: Java enforces strict type checking at compile-time, reducing runtime errors
  6. Distributed
  7. Multithreading
    Enables the concurrent execution of multiple parts of a program
  9. High Performance
    Some times java uses Just In Time (JIT) compiler, only compiles methods that are called making applications to execute faster

• Some Essential Java Terminologies:
  ♦ In Java, programmers can’t delete the objects. To delete or recollect that memory JVM uses the  Garbage Collector. Garbage cannot recover the memory of objects being referenced

• Disadvantages of Java: Performance can be slower compared to other programming languages like C++, due to its use of a virtual machine and automatic memory management.


--- Basic Syntax ---
• Terminologies of a Basic Java Program
  //Since it is class based:
  ► 1. Class Declaration
	A class is a blue print of an object
  ► 2. Object
	The object is an instance of a class
  ► 3. Main Method
	Entry point where the program starts execution
  ► 4. Statements
	Each line of code that ends with ';'
• Identifiers
    Unique names given to Variables, Classes, Methods, Packages, Interfaces, etc.
• Key / Reserved Words
    In Java there are 53, that should not be used as identifiers
• Source File Name
    When There is a public class in the file the file name must exactly match the name of the public class name. If there is no public class or the class is not public the filename doesn't matter


-- SCOPE | Access & Non-access MODIFIERS --
Access Modifiers:
  ○ default, public, protected, private
Non-access Modifiers:
  ○ final, abstract, static, transient, synchronized, volatile, native

• Explanation of the base syntax:
   public static void main(String[] args)
  ► public  : So that  JVM  can execute the method from anywhere. 
  ► static  : The main method is to be called without an object. The modifiers are public and static can be written in either order. 
  ► void  : The main method doesn’t return anything. 
  ► main()  : Name configured in the JVM. The main method must be inside the class definition. 
  ► String[]  : The main method accepts a single argument, i.e., an array of elements of type String. 


-- Data Types --
Are values that can be stored in variables
A) Primitive types
    byte(8 bits), short(16), int(32), long(64), float(32), double(64), char and boolean
    • Java uses the UNICODE character set to support internationalization
      C & C++ use ASCII
      Thus, char requires to be size 2 bytes(16 bits)
B) Non-primitive or REFERENCE types
    String, Array, etc.
  1. String  : array of characters. Java strings are not terminated with a null character unlike C
  2. Array   : group of like-typed variables
	+ All arrays are dynamically allocated
	+ The direct superclass of an array type is Object
	+ Every array type implements the interfaces Cloneable and java.io.Serializable
  3. Class   : class declarations can include: Modifiers(to specify access), ClassName, Superclass(preceded by 'extends'), Interfaces(if-any, preceded by 'implements', Body({})
  4. Object  : is a basic unit of OOP and represents real-life entities. Consist of: 
	+ State -> attributes & properties of an object
	+ Behavior -> rep. by it's methods, and reflects it's response
	+ Identity -> gives it a unique name and enables it to interact with other objects
  5. Interface : Like a class, it can have methods and variables, but the methods declared in an interface are by default abstract (only method signature, no body). The Class has to implement / provide the method bodies, or else the class must be declared abstract

KEY POINTS
○ STRONG TYPING: Java enforces strict type checking at compile-time, reducing runtime errors.
○ MEMORY EFFICIENCY: Choosing the right data type based on the range and precision needed helps in efficient memory management.
○ IMMUTABILITY OF STRINGS: Strings in Java cannot be changed once created, ensuring safety in multithreaded environments.


-- Variables --
Are data containers, or memory location name for data.
• They have: +Data Type, +Variable Name, +Value
• There are 3 kinds in Java:
	+Local : these are destroyed once exiting the block where it was declared
	+Instance : + they are declared in a class
		+ created and destroyed with an object
		+ can use access specifiers
		+ Initialization is not mandatory
		+ If no initialized, values will be:
		  - String = null
		  - int = 0
		  - float = 0.0f
		  - Wrapper classes like 'Integer' = null, etc.
	+Static : also known as 'class variables'
		+ these are similar to instance variables, but must use the 'static' keyword 4 declaration
		+ these are created at the start of a program execution and destroyed on end
		+ Declaring a static variable inside a block that is not a StaticBlock 
*		+ If we access a static variable like an instance variable (through an object) or without a class name, the compiler will show a warning message, which won’t halt the program. The compiler will replace(or append) the object name with the class name automatically.
		*// If we want to execute some code once for all objects of a class then we will be using Static Block in Java. If we want to execute it everytime an object is created we use an 'Instance Block'


-- Scope in Java --
Scope of a variable defines the region of the program where the variable can be accessed

types of Scopes:
1. Local scope
2. Instance Scope
3. Class Scope
4. Parameter Scope
5. Block Scope


-- Java Operators --
Special symbols that are used for performing Operations.

• Types of operations in Java: Arithmetic, Unary, Assignment, Relational, Logical, Ternary, Bitwise, Shift, instance of operator

// for the following must use binary numbers: 0b1010
• Bitwise : is for manipulating individual bits of a number. They are used when performing update and query operations of the Binary indexed trees. &, |, ^, ~, and , or, xor, complement(inverts all, one's complement), respectively.
• Shift : used to shift the bits of a number left or right, thereby multiplying or dividing the number by two, respectively.
  ♦ << (Left shift) – Shifts bits left, filling 0s (multiplies by a power of two).
  ♦ >> (Signed right shift) – Shifts bits right, filling 0s (divides by a power of two), with the leftmost bit depending on the sign.
  ♦ >>> (Unsigned right shift) – Shifts bits right, filling 0s, with the leftmost bit always 0.
ie.: number shift_op number_of_places_to_shift; 
• Instance of Operator : used for type checking. ie.: object instancof class/subclass/interface 

• ***Precedence*** and Associativity of Java Operators: Must review orders table. Highest order top:
Unary postfix   (++ --)
Unary prefix    (++ -- + - ~ ! (type))
Multiplicative  (* / %)
Additive        (+ -)
Shift           (<< >> >>>)
Relational      (< <= > >=)
Equality        (== !==)
Boolean Logical AND           (&)
Boolean Logical Exclusive OR  (^)
Boolean Logical Inclusive OR  (|)
Conditional AND (&&)
Conditional OR  (||)
Conditional     (?:)
Assignment      (= += -= *= /= %=)

• Be a Compiler: The compiler in our systems uses a lex tool to match the greatest match when generating tokens
	ie.: int a = 20, b = 10, c = 0;
	     a=b+++c;
	// a=b+++c is compiled as
	// a = b++ +c
        // b++ +c
        // a=b+c then b=b+1
	// so ends as: a = 10, b: 
  + talking about the 'tokens': the token created by lex is a, =, b, ++, +, c.

• Inside system.out.println() make sure to do addition using parenthesis, to avoid string concatenation instead of addition

• Java doesn’t support Operator Overloading


-- User Input --
with class:
• Scanner,  part of java.util package
  + Introduced in Java 5
  + use ie.: Scanner scn = new Scanner(System.in);
  + has the methods: next(), nextLine(), nextBoolean/Byte/Int/Short/Long/Float/Double(). Each for reading specific values
    ○ nextInt/Float() leave the newline character in the input buffer, so if you call nextLine() right after, it will read this newline as input instead of a new line
  Main characteristics:
    - Reads formatted input
    - Best suited for small data types
    - Slow due to parsing overhead (e.g., nextInt(), nextFloat())
• BufferedReader
  + has the methods:
    ◘ read():  Reads a single character
    ◘ read(char[] cbuf): Reads an array of characters
    ◘ readLine(): Reads an entire line of text
  + Main characteristics:
    - Faster for large input as it does less parsing
    - Exceptions handling (IOException)
    - Thread-safe, due to Synchronization


-- Flow Control / Conditioning --
• if  statement
• if-else
• if-else-if  (sequential conditioning & fallback mechanism)
  ♦  if we do not provide the curly braces ‘{‘ and ‘}’ after if( condition ) then by default if statement will consider the immediate one statement to be inside its block
• for loop
  ♦  ie.: for(initialization; condition/test; updation) { body }
• for-each / Enhanced For Loop
  ♦  ie.: for(type var : array) { }
  ♦  Limitations:
    - cannot modify array elements directly
    - no access to index
    - single-direction only
• while() {}  // can run without {}
• do{} while();
  ♦  when you want the code to run at least once
• break,  breaks the loop immediately
  ♦  In LABELED BLOCKS, Java allows using break with labels to exit from nested blocks. It often referred to as an alternative to the goto statement.
    ◙  ie.:
      first: {
        second: {
          //Block of statements
          break first;
        }
      }
• continue,  skips current iteration and move to next one
• return,  used to exit from a method, with or without a value
  ♦  In methods with return type void, it can be used without a value, as an exit method
    ◙  ie.:
      public class Geeks {
        void demoFunc(double n) { if (n < 9) return; n++; }
        ...main...{
          new Geeks().demoFunc(5);
        }
      }


-- Methods --
Are blocks of code that perform a specific task
• All methods in Java must belong to a class
• Are similar to functions and expose the behavior of objects
• Syntax:
  <access_Modifier> <Return_Type> <method_Name>(list_of_Parameters)
{
    //Body
}
  ie.: public void test() { //code block }
  ♦  modifiers,  (public, private, protected, or default)

• Method Naming
  ♦ typically a single word that should be a VERB in lowercase
  ♦ or multi-word, that begins with a VERB in lowercase followed by an ADJECTIVE, NOUN
  ♦ After the first word, the first letter of each word should be capitalized

Types of Methods in Java
• Predefined methods,  are already defined in Java class libraries
• User-defined methods
  There are 2 types:
  ♦  Instance Method,  Declared inside a class
  ♦  Static Method,   Access the static data using class name. Declared inside class with static keyword
  ♦  Abstract Methods,  is used for creating blueprints for classes or interfaces. Abstract classes can also be seen as  super-classes
    ◘  These need to use the 'abstract' reserved word
    ◘  They can only be implemented using subclasses or classes that implement the interfaces
    ◘  They are sometimes referred to as subclass responsibility because they have no implementation specified in the super-class. Thus, a subclass must override them to provide a method definition

• Method Overloading & Method Signature
A method name can be defined in different ways to make different methods
It consists of the method name and a parameter list.
  ♦ number of parameters
  ♦ type of the parameters
  ♦ order of the parameters

• Memory Allocation for Methods Calls
Methods calls are implemented through a stack, whenever a method is called
  ♦  the stack frame stores the arguments passed to and the local variables and value to be returned by this called method, which'll be deleted upon completion
  ♦  There is a stack pointer register that tracks the top of the stack which is adjusted accordingly

• Advantages
  ♦  Reusability
  ♦  Abstraction
  ♦  Encapsulation
  ♦  Modularity
  ♦  Customization
  ♦  Improved Performance


-- How to Call a Method in Java? --
Calling the
  + Abstract Methods:  by creating an instance of the public-class that extended from the abstract-class that has the abstract-method. And calling the method on that instance
  + Predefined(/Instance) Methods:  by just calling the method on the object needed
    //(Instance Methods) are very similar, in use, to predefined methods, but can be created by you
    - they belong to the object
    ** Use instance methods for operations that depend on the state of an object.
  + Static Methods:  class.method();
    - they belong to the class
    ** Use static methods for class-level operations or utilities.

//* Method Hidding.  when both superclass and subclass have static methods with the same name, thus the subclass method hides the superclass method

//* the Heap,   is a region of memory used for Dynamic Memory Allocation. is where 'new' objects are stored (the onse that use the 'new' keyword to instantiate them)


-- Access Modifiers --
Keywords that control the visibility and accessibility of classes, methods, and variables
*Thus ensuring better security and encapsulation
Main Types:
• Default – No keyword required,  are accessible only within the same package (Package-Private)
• Private:  “only visible within the enclosing class”
• Protected:  “only visible within the enclosing class and any subclasses”
• Public,  are accessible from everywhere in the program

All 12  modifiers in Java:
  public      static          native
  private     final           strictfp
  protected   synchronized    transient
  default     abstract        volatile


-- Command Line Arguments --
is an argument passed at the time of running the Java program and can be used as input
ie.:
public static void main(String[] args) { System.out.println(args[0]); }
• these are passed as space-separated values
• can be both strings and primitive data types
• they're converted into a string array and provided to the main() function


-- Variable Arguments (Varargs) --
• is a method that takes a variable number of arguments
• is specified by three periods or dots(…)
• From JDK 5 onwards, we can declare a method with a variable number of arguments.
• ie.:  public static void Names(String... n)
• ie.:  static void fun2(String s, int... a)
***  should ensure that there exists ONLY ONE Varargs parameter that should be Written Last in the parameter list of the method declaration

• Vararg Methods can also be overloaded, but overloading may lead to ambiguity.


-- Arrays --
Are structures that store multiple values of the same type in a single variable
• For primitive arrays,  elements are stored in a contiguous memory location.
• For non-primitive arrays,  references are stored at contiguous locations, but the actual objects may be at different locations in memory
• The size of an array is fixed

• Declaration:  type[] var-name;  OR  type var-name[]; 
*//   *** You cannot define the size of an array in the declaration:
       int arr[2];   // Compiler Error
• Creation/Initialization:  var-name = new type[size];
    or with specific values:  int[] arr = {1, 2, 3, 4, 5};
• Access/modification:  numbers[0] = 10;
• We can get the length of an array using the 'length property'
   int length = numbers.length;
• By default, new arrays will automatically be initialized to Zero (for numeric types), False (for boolean), or Null (for reference types)
• In Java, all arrays are dynamically allocated

• Declaring array literal  
   int[] intArray = new int[]{ 1,2,3,4,5,6,7,8,9,10 };
• 2D Arrays are also called Matrix
   datatype [][] arrayrefvariable;
• Multidimensional Arrays are also called Jagged Arrays,
   arrays of arrays
  ♦  int[][] arr = { { 1, 2 }, { 3, 4 } };
  ♦*** Multidimensional arrays in Java are not stored in tabular form. Each row is independently heap allocated, making it possible to have arrays with 'different row sizes'.
  ♦ JAGGED arrays,  are arrays with member of different sizes
    ◘  ie.:  arr [][]= { {1,2}, {3,4,5,6},{7,8,9}};
• Array Types
  ♦ Primitive Type
  ♦ Object Type
  ♦ Abstract Class Type
  ♦ Interface Type

• Returning Arrays from Methods
  ♦  return new int[] { 1, 2, 3 };
• Java Array Members
  ♦  All the members are inherited from class Object; the only method of Object that is not inherited is its clone method
  ♦  The public method clone() overrides the clone method in class Object and throws no checked exceptions
• Cloning Arrays in Java (with the clone() method)
  ♦  When you clone a single-dimensional array, such as Object[], a shallow copy is performed ==> the new array contains references to the original array’s elements
  ♦  only with arrays containing primitive data types the actual values are copied
  ♦  ie.:  int cloneArray[] = intArray.clone();
  ♦  With a Multi-Dimensional Array clone
    ◘  subarrays are shared
    ◘  ie.: int cloneArray[][] = intArray.clone();
            intArray == cloneArray        // false
            intArray[0] == cloneArray[0]  // true
            intArray[1] == cloneArray[1]  // true

• The direct superclass of an array in Java is Object
  ♦  Thus, inherit methods like: toString(), equals(), and hashCode()

- Advanced Initialization Using Streams -
An array can be initialized by using a stream interface. The IntStream interface in Java offers additional ways to initialize arrays with sequential or predefined values
• int[] arr1 = java.util.stream.IntStream.range(1, 5).toArray();   // Output: 1 2 3 4
• int[] arr2 = java.util.stream.IntStream.rangeClosed(1, 4).toArray();   // Output: 1 2 3 4
• int[] arr3 = java.util.stream.IntStream.of(1, 2, 3, 4).toArray();   // Output: 1 2 3 4  'specific values'

- Declaration & Initialization of Jagged Arrays -
• Jagged arrays let you specify the size of each sub-array at runtime, rather than at compile-time
different methods of d&i
• 1)
arr [][]= { {1,2}, {3,4,5,6},{7,8,9}};
• 2)
data_type array_name[][] = new data_type[n][];     // n= no. of rows

array_name[] = new data_type[n1]        //n1= no. of columns in row-1
array_name[] = new data_type[n2]       //n2= no. of columns in row-2
                                   .
                                   .
array_name[] = new data_type[nk]        //nk=no. of columns in row-n
• 3)
int arr_name[][] = new int[][]  { 
                                  new int[] {10, 20, 30 ,40},
                                  new int[] {50, 60, 70, 80, 90, 100},
                                  new int[] {110, 120}
                              };
• 4)
int[][] arr_name = { 
                                new int[] {10, 20, 30 ,40},
                                 new int[] {50, 60, 70, 80, 90, 100},
                                 new int[] {110, 120}
                             };
• disadvantages
  ♦  increased complexity in the code and a potentially less readable codebase, so they should be used carefully and appropriately


-- Arrays class in Java --
The Arrays class in java.util package is a part of the Java Collection Framework
• This class provides static methods to dynamically create and access Java arrays
• to optimize our code, with ie.: fill, sort, search, etc
• Class declaration
    public class Arrays extends Object
• to make use of Arrays methods 
    Arrays.<function/method name>;
• Methods in Java Array Class:
 asList()
 binarySearch(array, searchFor)
 binarySearch(array, fromIndex, toIndex, key, Comparator)
 compare(array 1, array 2)
 copyOf(originalArray, newLength)
 copyOfRange(originalArray, fromIndex, endIndex)
 deepEquals(Object[] a1, Object[] a2)
 deepHashCode(Object[] a)
 deepToString(Object[] a)
 equals(array1, array2)
 fill(originalArray, fillValue)
 hashCode(originalArray)
 mismatch(array1, array2)
 parallelPrefix(originalArray, fromIndex, endIndex, functionalOperator)
 parallelPrefix(originalArray, operator)
 parallelSetAll(originalArray, functionalGenerator)
 parallelSort(originalArray)
 setAll(originalArray, functionalGenerator)
 sort(originalArray)
 sort(originalArray, fromIndex, endIndex)
 sort(T[] a, int fromIndex, int toIndex, Comparator< super T> c)
 sort(T[] a, Comparator< super T> c)
 spliterator(originalArray)
 spliterator(originalArray, fromIndex, endIndex)
 stream(originalArray) 
 toString(originalArray) 

- Final Arrays in Java -
As any other object variable that is declared with the 'final' reserved word,
* can only be initialized or Referenced ONCE, but the content CAN change.

-- Strings --
Is a type of objects that can store the sequence of characters
• And every character is stored in 16 bits i.e using UTF 16-bit encoding
• There are 2 ways of creating Java Strings:
  ◘  String Literal (Static Memory)
    ie.:  String demoString = “GeeksforGeeks”; 
    ♦  Makes memory efficient (because no new objects are created if it exists already in the string constant pool)
  ◘  Using new Keyword (HEAP Memory)
    ie.:  String str = new String("GeeksforGeeks");
    ♦  here Java will create a new string object in normal (non-pool) heap memory
    ♦  and it will return the reference to the same instance
• String is an immutable class which means a constant and cannot be changed once created.
Thus it is automatically thread safe

- Interfaces and Classes in Strings -
Also, the following class can be used:
• CharBuffer class
  ◘  implements the CharSequence interface; uses regex
•  CharSequence
  ◘  is used for representing the sequence of Characters
  ◘  The following are implemented using the CharSequence interface:
    ♦  String
    ♦  StringBuffer
      ○  is a peer class of String
      ○  it is mutable in nature and it is thread safe class ○  can be used for multi threaded environment and shared object of string buffer
    ♦  StringBuilder
      ○  creates a mutable sequence of characters and it is NOT thread safe
      ○  You can modify it, like:  demoString.append(“GFG”);
    ♦  StringTokenizer
      ○  is used to break a string into tokens(words)
    Which means that this provides much of functionality like substring, lastoccurence, first occurence, concatenate , toupper, tolower etc
      ○*  StringJoiner ,  is a class in java.util package
        ☺  used to construct a sequence of characters(strings) separated by a delimiter
        ☺  optionally starting with a supplied prefix and ending with a supplied suffix
  •* The Cache that stores all created string instances is known as the STRING CONSTANT POOL or String Pool

*** Just to make that memory detail clear:
*  The String Pool is a special memory region where Java stores string literals
*  String Literals: When you create a string using string literal syntax, like String s1 = "hello", it is automatically stored in the String Pool
*  If the string already exists in the pool, it won't be duplicated
*  String Objects Created Using the new Keyword: When you create a string using the 'new' keyword, it creates a new object on the heap
*  However, if the string literal "hello" is already in the String Pool, the new String("hello") will reference the existing "hello" string in the pool,
*  but the new String object itself is still created on the heap.

• If you want to explicitly store a string in the constant pool, you need to 'intern' it
  ie.:  String internedString = demoString.intern();

//*** Strings are immutable for security, performance, and thread safety reasons. It prevents unwanted changes and helps optimize memory usage.




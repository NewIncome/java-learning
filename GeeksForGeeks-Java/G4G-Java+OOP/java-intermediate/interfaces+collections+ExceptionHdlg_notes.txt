--- Java Interfaces ---
An interface in Java is a blueprint of a behaviour.
It is a Contract defined as an abstract type used to specify the behaviour of a class.
• Key concepts:
  ○  is a mechanism to achieve abstraction and multiple inheritance
  ○  by default variables in an interface are public, static, and final
  ○  supports loose coupling (classes depend on behavior, not implementation)
    ♦  In other words, interfaces primarily define methods that other classes must implement
//* Note: When we decide on a type of entity by its behaviour and not via attribute we should define it as an interface
• Relationship Between Class and Interface
  class       interface     interface
    ^extends    ^implements     ^extends
  class       class         interface
//New feats added after JDK 8
• Method Types for interfaces
  ○  'default' methods
    ♦  provide a method implementation within the interface itself
  ○  'static' methods
    ♦  are called directly using the interface name and are not inherited by implementing classes
  ○  'private' methods
    ♦  cannot be overridden nor accessed by implementing classes, as they are not inherited

***- Functional Interface -***
Is an interface that contains exactly one abstract method
•* Enables Functional Programming Concepts in Java
  ○  allowing you to pass behavior as arguments to methods, return behavior from methods, and treat functions as first-class citizens
• Single Abstract Method (SAM): The interface contract specifies only one behavior that implementing classes must provide
• It needs the @FunctionalInterface Annotation (optional but recommended)
• Can Contain Static and Default Methods: Functional interfaces can have any number of static methods
  (which are called on the interface itself) and default methods (which provide a default implementation
  for the implementing classes). These don't violate the "single abstract method" rule because they already have implementations
• Basic syntax:
    @FunctionalInterface
    interface MyFunctionalInterface {
      void singleAbstractMethod();
    }
•* Primarily used to support lambda expressions and method references
  ○*  enable you to treat functionality as data
• In use with Lambda Expressions:
    interface MyOperation {
      int operate(int a, int b);
    }
    public class Main {
      public static void main(String[] args) {
        // Lambda expression implementing MyOperation
        MyOperation addition = (int x, int y) -> x + y;
        MyOperation subtraction = (a, b) -> a - b; // Type inference

        System.out.println(addition.operate(5, 3));     // Output: 8
        System.out.println(subtraction.operate(5, 3));  // Output: 2
    ...
• In use with Method References:
    import java.util.List;
    import java.util.Arrays;
    import java.util.function.Consumer;
    ...
    // Functional Interface: Consumer<String> (accepts a String and returns void)
    // Method reference to the static method printUpperCase
    Consumer<String> printer = Main::printUpperCase;
    names.forEach(printer); // Output: ALICE, BOB, CHARLIE
    // Method reference to an instance method
    List<String> greetings = Arrays.asList("hello ", "hi ", "hey ");
    greetings.forEach(System.out::print); // Output: hello hi hey
• java.util.function package
  ○  is a rich set of built-in functional interfaces for many common use cases
    ♦  Consumer<T>: Represents an operation that accepts a single input argument and returns no result.   
      ◘  ( s.a.m.: void accept(T t) )
    ♦  Supplier<T>: Represents a supplier of results.
      ◘  ( sam: T get() )
    ♦  Function<T, R>: Represents a function that accepts one argument and produces a result.   
      ◘  ( sam: R apply(T t) )
    ♦  Predicate<T>: Represents a predicate (a boolean-valued function) of one argument.   
      ◘  ( sam: boolean apply(T t) )
    ♦  UnaryOperator<T>: Represents an operation on a single operand that produces a result of the same type as its operand.   
    ♦  BinaryOperator<T>: Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
    ♦  Runnable ( s.a.m.: void run() )
    ♦  Callable<V> ( sam: V call() throws Exception )
    ♦  Comparator<T> ( sam: int compare(T o1, T o2) )

•* Extending Interfaces
  ○  When a class implements an interface that inherits another interface,
     it must provide an IMPLEMENTation for ALL METHODS required by the INTERFACE inheritance chain.

• Steps of the development process, in general:
  Level 1 – interfaces: It contains the service details.
  Level 2 – abstract classes: It contains partial implementation.
  Level 3 – implementation classes: It contains all implementations.
  Level 4 – Final Code / Main Method: It have access of all interfaces data.

• Important Points:
  ○  A class that implements the interface must implement all the methods in the interface
  ○  All the methods are public and abstract
  ○  All the fields are public, static, and final; due to this it's not possible to declare instance variables
  ○  It is used to achieve multiple inheritances
  ○  It is used to achieve loose coupling
  ○  Interfaces are about "What" not 'How'

-- Interfaces and Inheritance --
Is a mechanism in which one object acquires all the properties and behaviors of a parent object
• Fundamental principle of 'class-based inheritance'
  ○  The Is-A relationship, is where a subclass is a more specialized version of its superclass
    ♦  which is also known as the "Parent-Child relationship"
    ♦ Dog IS_A Animal , Car IS_A Vehicle , Employee IS_A Person
• Types of inheritance, between classes
  ○  Single-level , Multi-level , and Hierarchical
• With interfaces you can achieve
  ○  Multiple & Hybrid inheritance
  ○  Multiple Inheritance is not supported by class because of ambiguity
//* From Java 8, interfaces also have implementations of methods.
    So if a class implements two or more interfaces having the same method signature
    with implementation, it is mandated to implement the method in class also.

-- Class vs Interfaces --
• Main Difference:
  ○  A class defines the state of behaviour of objects
  ○  An interface is lika a contract,
     that defines the methods that a class must implement
  ○  an Interfaces:
    ♦  cannot be instantiated directly, instead, it is implemented by a class or a struct
    ♦  contains abstract methods by default (< Java 8)
       or default/static methods (>=Java 8 onward)
    ♦  All variables and methods are declared public
    ♦  All variables are static and final
    ♦  is focused on capabilities
    ♦  methods declared in the interface are by default abstract (only method signature, nobody)

-- Functional Interfaces (SAM Interfaces) --
• is an interface that contains only one abstract method
• can have multiple default or static methods, but only one abstract method
• Runnable, ActionListener, and Comparator are common examples of Java functional interfaces
• From Java 8 onwards, lambda expressions and method references can be used to represent the instance of a functional interface
//• Note: A functional interface can also extend another functional interface

- @FunctionalInterface Annotation -
This annotation is used to ensure that the functional interface cannot have more than one abstract method
• The “Unexpected @FunctionalInterface annotation” error ocurrs at compilation if more than one abstract methods are present
//Note: @FunctionalInterface annotation is optional but it is a good practice to use
• ie.:  
    @FunctionalInterface
    interface Square { int calculate(int x); }
    ... main .. {
      Square s = (int x) -> x * x; //This is how you implement & instantiate a FunctionalInterface Method
      int squareValue = s.calculate(5);
    }
/* 
 * • Functional Interfaces Before Java 8
 *   ○  had to create anonymous inner class objects or implement these interfaces
 *   ○  ie.:
        // create anonymous inner class object
        new Thread(new Runnable() {
            @Override public void run()
            {
                System.out.println("New thread created");
            }
        }).start();
*/
• Built-In Java Functional Interfaces
These are cointained in the java.util.function package
  ○  Runnable:        only contains the run() method
  ○  Comparable:      only contains the compareTo() method
  ○  ActionListener:  only contains the actionPerformed() method
  ○  Callable:        only contains the call() method
• Types of Functional Interfaces in Java
Java SE 8 included four main kinds of functional interfaces which can be applied in multiple situations
  1. Consumer
    ♦  accepts only one argument or a gentrified argument
    ♦  has no return value
    ♦  there are variants —  DoubleConsumer, IntConsumer, and LongConsumer (the before accept primitive values as arguments), 
    ♦  also, a last variant:  Bi-Consumer
    ♦  Syntax:  Consumer<Integer> consumer = (value) -> System.out.println(value);
  2. Predicate
    ♦  represents a boolean-valued function of one argument
    ♦  It is commonly used for filtering operations in streams
    ♦  extensions:  IntPredicate, DoublePredicate, and LongPredicate
    ♦  No-lambda syntax:  public interface Predicate<T> { boolean test(T t); }
    ♦  Syntax:  Predicate predicate = (value) -> value != null;
  3. Function
    ♦  receives only a single argument and returns a value after the required processing
    ♦  extensions:  Bi-Function(takes 2 args), UnaryOperator, and BinaryOperator
    ♦  Syntax:  Function<Integer, Integer> function = (value) -> value * value;
  4. Supplier
    ♦  does not take any input or argument
    ♦  returns a single output
    ♦  extensions:  BooleanSupplier, DoubleSupplier, LongSupplier, and IntSupplier
    ♦  Syntax:  Supplier<String> supplier = () -> “Hello, World!”;    

-- Nested Interfaces --
• A nested interface can be declared public, protected, package-private (default), or private
• A top-level interface (not nested) can ONLY be declared as public or package-private (default)
• When implementing a nested interface, we refer to it as 'i_first.i_second'
  ○  or c_name.i_name  for an interface inside a class
• ie.:
    class Parent { interface Test { void show(); } }
    class Child implements Parent.Test { @Override public void show() {...




--- Java Collections ---


--- Java Exception Handling ---



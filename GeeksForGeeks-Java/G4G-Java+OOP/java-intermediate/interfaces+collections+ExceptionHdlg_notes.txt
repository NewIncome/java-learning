--- Java Interfaces ---
An interface in Java is a blueprint of a behaviour.
It is a Contract defined as an abstract type used to specify the behaviour of a class.
• Key concepts:
  ○  is a mechanism to achieve abstraction and multiple inheritance
  ○  by default variables in an interface are public, static, and final
  ○  supports loose coupling (classes depend on behavior, not implementation)
    ♦  In other words, interfaces primarily define methods that other classes must implement
//* Note: When we decide on a type of entity by its behaviour and not via attribute we should define it as an interface
• Relationship Between Class and Interface
  class       interface     interface
    ^extends    ^implements     ^extends
  class       class         interface
//New feats added after JDK 8
• Method Types for interfaces
  ○  'default' methods
    ♦  provide a method implementation within the interface itself
  ○  'static' methods
    ♦  are called directly using the interface name and are not inherited by implementing classes
  ○  'private' methods
    ♦  cannot be overridden nor accessed by implementing classes, as they are not inherited

***- Functional Interface -***
Is an interface that contains exactly one abstract method
•* Enables Functional Programming Concepts in Java
  ○  allowing you to pass behavior as arguments to methods, return behavior from methods, and treat functions as first-class citizens
• Single Abstract Method (SAM): The interface contract specifies only one behavior that implementing classes must provide
• It needs the @FunctionalInterface Annotation (optional but recommended)
• Can Contain Static and Default Methods: Functional interfaces can have any number of static methods
  (which are called on the interface itself) and default methods (which provide a default implementation
  for the implementing classes). These don't violate the "single abstract method" rule because they already have implementations
• Basic syntax:
    @FunctionalInterface
    interface MyFunctionalInterface {
      void singleAbstractMethod();
    }
•* Primarily used to support lambda expressions and method references
  ○*  enable you to treat functionality as data
• In use with Lambda Expressions:
    interface MyOperation {
      int operate(int a, int b);
    }
    public class Main {
      public static void main(String[] args) {
        // Lambda expression implementing MyOperation
        MyOperation addition = (int x, int y) -> x + y;
        MyOperation subtraction = (a, b) -> a - b; // Type inference

        System.out.println(addition.operate(5, 3));     // Output: 8
        System.out.println(subtraction.operate(5, 3));  // Output: 2
    ...
• In use with Method References:
    import java.util.List;
    import java.util.Arrays;
    import java.util.function.Consumer;
    ...
    // Functional Interface: Consumer<String> (accepts a String and returns void)
    // Method reference to the static method printUpperCase
    Consumer<String> printer = Main::printUpperCase;
    names.forEach(printer); // Output: ALICE, BOB, CHARLIE
    // Method reference to an instance method
    List<String> greetings = Arrays.asList("hello ", "hi ", "hey ");
    greetings.forEach(System.out::print); // Output: hello hi hey
• java.util.function package
  ○  is a rich set of built-in functional interfaces for many common use cases
    ♦  Consumer<T>: Represents an operation that accepts a single input argument and returns no result.   
      ◘  ( s.a.m.: void accept(T t) )
    ♦  Supplier<T>: Represents a supplier of results.
      ◘  ( sam: T get() )
    ♦  Function<T, R>: Represents a function that accepts one argument and produces a result.   
      ◘  ( sam: R apply(T t) )
    ♦  Predicate<T>: Represents a predicate (a boolean-valued function) of one argument.   
      ◘  ( sam: boolean apply(T t) )
    ♦  UnaryOperator<T>: Represents an operation on a single operand that produces a result of the same type as its operand.   
    ♦  BinaryOperator<T>: Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
    ♦  Runnable ( s.a.m.: void run() )
    ♦  Callable<V> ( sam: V call() throws Exception )
    ♦  Comparator<T> ( sam: int compare(T o1, T o2) )

•* Extending Interfaces
  ○  When a class implements an interface that inherits another interface,
     it must provide an IMPLEMENTation for ALL METHODS required by the INTERFACE inheritance chain.

• Steps of the development process, in general:
  Level 1 – interfaces: It contains the service details.
  Level 2 – abstract classes: It contains partial implementation.
  Level 3 – implementation classes: It contains all implementations.
  Level 4 – Final Code / Main Method: It have access of all interfaces data.

• Important Points:
  ○  A class that implements the interface must implement all the methods in the interface
  ○  All the methods are public and abstract
  ○  All the fields are public, static, and final; due to this it's not possible to declare instance variables
  ○  It is used to achieve multiple inheritances
  ○  It is used to achieve loose coupling
  ○  Interfaces are about "What" not 'How'

-- Interfaces and Inheritance --
Is a mechanism in which one object acquires all the properties and behaviors of a parent object
• Fundamental principle of 'class-based inheritance'
  ○  The Is-A relationship, is where a subclass is a more specialized version of its superclass
    ♦  which is also known as the "Parent-Child relationship"
    ♦ Dog IS_A Animal , Car IS_A Vehicle , Employee IS_A Person
• Types of inheritance, between classes
  ○  Single-level , Multi-level , and Hierarchical
• With interfaces you can achieve
  ○  Multiple & Hybrid inheritance
  ○  Multiple Inheritance is not supported by class because of ambiguity
//* From Java 8, interfaces also have implementations of methods.
    So if a class implements two or more interfaces having the same method signature
    with implementation, it is mandated to implement the method in class also.

-- Class vs Interfaces --
• Main Difference:
  ○  A class defines the state of behaviour of objects
  ○  An interface is lika a contract,
     that defines the methods that a class must implement
  ○  an Interfaces:
    ♦  cannot be instantiated directly, instead, it is implemented by a class or a struct
    ♦  contains abstract methods by default (< Java 8)
       or default/static methods (>=Java 8 onward)
    ♦  All variables and methods are declared public
    ♦  All variables are static and final
    ♦  is focused on capabilities
    ♦  methods declared in the interface are by default abstract (only method signature, nobody)

-- Functional Interfaces (SAM Interfaces) --
• is an interface that contains only one abstract method
• can have multiple default or static methods, but only one abstract method
• Runnable, ActionListener, and Comparator are common examples of Java functional interfaces
• From Java 8 onwards, lambda expressions and method references can be used to represent the instance of a functional interface
//• Note: A functional interface can also extend another functional interface

- @FunctionalInterface Annotation -
This annotation is used to ensure that the functional interface cannot have more than one abstract method
• The “Unexpected @FunctionalInterface annotation” error ocurrs at compilation if more than one abstract methods are present
//Note: @FunctionalInterface annotation is optional but it is a good practice to use
• ie.:  
    @FunctionalInterface
    interface Square { int calculate(int x); }
    ... main .. {
      Square s = (int x) -> x * x; //This is how you implement & instantiate a FunctionalInterface Method
      int squareValue = s.calculate(5);
    }
/* 
 * • Functional Interfaces Before Java 8
 *   ○  had to create anonymous inner class objects or implement these interfaces
 *   ○  ie.:
        // create anonymous inner class object
        new Thread(new Runnable() {
            @Override public void run()
            {
                System.out.println("New thread created");
            }
        }).start();
*/
• Built-In Java Functional Interfaces
These are cointained in the java.util.function package
  ○  Runnable:        only contains the run() method
  ○  Comparable:      only contains the compareTo() method
  ○  ActionListener:  only contains the actionPerformed() method
  ○  Callable:        only contains the call() method
• Types of Functional Interfaces in Java
Java SE 8 included four main kinds of functional interfaces which can be applied in multiple situations
  1. Consumer
    ♦  accepts only one argument or a gentrified argument
    ♦  has no return value
    ♦  there are variants —  DoubleConsumer, IntConsumer, and LongConsumer (the before accept primitive values as arguments), 
    ♦  also, a last variant:  Bi-Consumer
    ♦  Syntax:  Consumer<Integer> consumer = (value) -> System.out.println(value);
  2. Predicate
    ♦  represents a boolean-valued function of one argument
    ♦  It is commonly used for filtering operations in streams
    ♦  extensions:  IntPredicate, DoublePredicate, and LongPredicate
    ♦  No-lambda syntax:  public interface Predicate<T> { boolean test(T t); }
    ♦  Syntax:  Predicate predicate = (value) -> value != null;
  3. Function
    ♦  receives only a single argument and returns a value after the required processing
    ♦  extensions:  Bi-Function(takes 2 args), UnaryOperator, and BinaryOperator
    ♦  Syntax:  Function<Integer, Integer> function = (value) -> value * value;
  4. Supplier
    ♦  does not take any input or argument
    ♦  returns a single output
    ♦  extensions:  BooleanSupplier, DoubleSupplier, LongSupplier, and IntSupplier
    ♦  Syntax:  Supplier<String> supplier = () -> “Hello, World!”;    

-- Nested Interfaces --
• A nested interface can be declared public, protected, package-private (default), or private
• A top-level interface (not nested) can ONLY be declared as public or package-private (default)
• When implementing a nested interface, we refer to it as 'i_first.i_second'
  ○  or c_name.i_name  for an interface inside a class
• ie.:
    class Parent { interface Test { void show(); } }
    class Child implements Parent.Test { @Override public void show() {...
• Uses:
  ○  To group related interfaces together; readability, organization
  ○  To create more secure code; limiting scope
  ○  To implement multiple interfaces; avoids cluttering up the global namespace with too many interface names
  ○  To create callbacks
  ○  To define a contract between classes; code more modular

-- Marker Interface --
is an empty interface means having no field or methods
• Examples:
  ○  Serializable
    ♦  present in java.io package
  ○  Cloneable
    ♦  present in java.lang package
    ♦  Invoking Object's clone method on an instance of the class that does not implement the Cloneable interface results in an exception CloneNotSupportedException being thrown
    ♦  By convention, classes that implement this interface should override Object.clone() method
  ○  Remote
    ♦  present in java.rmi package
    ♦  A 'remote' object is an object which is stored at one machine and accessed from another machine
    ♦  RMI (Remote Method Invocation) provides some convenience classes that remote object implementations can extend

-- Comparator Interface --
is used to sort the objects of user-defined classes
• present in java.util package
• allows custom comparison logic outside of the class for which instances we want to sort
• Compares 2 objects of the same class
• Useful when:
  ○  we need multiple sorting strategies for a class
  ○  we want to keep the sorting logic separate from the class
  ○* Suppose we have a list of Student objects, containing fields like roll no, name, address, DOB, etc,
     and we need to sort them based on roll no or name.
     We use Comparator here to define that logic separately.
• Syntax:  public int compare(Object obj1, Object obj2);
  ○  returns a negative integer if obj1 < obj2
  ○  returns 0 if both objects are equal
  ○  returns a positive integer if obj1 > obj2
• Contains 2 methods:
  ○  compare(Object obj1, Object obj2)
  ○  equals(Object element)

• sort() methods ,  of the Collections class is relevant here because it
  is used to sort the elements of a List by the given Comparator
  :. thus it internally calls the compare() method
  ○  present in java.util.Collections.sort
  ○  ie.:
      ♦ You can sort a List of Students by Age with lambdas like this:
         students.sort((p1, p2) -> Integer.compare(p1.age, p2.age));
      ♦ You can sort by 2+ properties with Comparator's comparing() & thenComparing(), like:
         students.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));
//* Note: new Comparator Interface methods: comparing() & thenComparing()

Feature	          Comparator           	Comparable
---------------------------------------------------------------
•Sorting Logic 	  Defined externally	  Defined within the class (Internally)
  Location
•Multiple Sorting    Supported         	Not supported
    Orders
•Interface       	  compare()           compareTo()
  Methods
•Functional            Yes               No
  Interface
•Usage	          Flexible and reusable   Simple and tightly coupled



--- Java Collections ---
• Collection: Any group of individual objects that are represented as a single unit
• "Collection Framework" holds all the Java Collection Classes and Interfaces
• There are 2 main interfaces:
  ○  Collection interface (java.util.Collection)
  ○  Map interface (java.util.Map)
• Main Interfaces of Collections:
  ○  List
  ○  Set
  ○  Queue
  ○  Map
  ○  conversions from one to another
• Framework ,  is a set of classes and interfaces which provide a ready-made architecture
• Advantages of the Collection Framework:
  ○  Consistent API
    ♦  has a basic set of interfaces like Collection, Set, List, or Map, all the
       classes (ArrayList, LinkedList, Vector, etc)
  ○  Reduces programming effort
    ♦  achieves abstraction
  ○  Increases program speed and quality
• Hierarchy of the Collection Framework
  ○  



--- Java Exception Handling ---


